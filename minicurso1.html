<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>R básico</title>
    <meta charset="utf-8" />
    <meta name="author" content="     R-Ladies Vitória" />
    <link rel="stylesheet" href="css\kunoichi.css" type="text/css" />
    <link rel="stylesheet" href="css\ninjutsu.css" type="text/css" />
    <link rel="stylesheet" href="css\rladies-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# R básico <br>
## meus primeiros passos no R <br><br><br>
### <br><br><br><br> R-Ladies Vitória
### nov/2019

---

layout: true

&lt;div class="my-footer"&gt;&lt;span&gt;

&lt;a href="https://www.meetup.com/pt-BR/R-Ladies-Vitoria"&gt;Meetup&lt;/a&gt; |
&lt;a href="https://twitter.com/rladiesvix"&gt;Twitter&lt;/a&gt; | 
&lt;a href="http://instagram.com/rladiesvix"&gt;Instagram&lt;/a&gt; |
&lt;a href="https://github.com/rladies/meetup-presentations_vitoria"&gt;Github&lt;/a&gt; 


&lt;/span&gt;&lt;/div&gt; 



&lt;!-- programação --&gt;
---
class: middle 

# Programação 

- R-Ladies

- Introdução ao R

- R básico

- Importação de dados

- Tratamento de dados

- Medidas descritivas

&lt;!-- R-Ladies --&gt;
---
class:  center

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="img/hexlogorladies.jpeg" alt="&amp;lt;center&amp;gt;&amp;lt;b&amp;gt; &amp;lt;/center&amp;gt;&amp;lt;/b&amp;gt;" width="18%" /&gt;
&lt;p class="caption"&gt;&lt;center&gt;&lt;b&gt; &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/div&gt;


- R-Ladies é uma organização mundial que **promove a diversidade de gênero** na comunidade R.

- Capacitar pessoas de gêneros sub-representados, criando e fortalecendo redes colaborativas dentro da comunidade R para que elas alcancem todas e quaisquer funções e áreas de participação no mundo da tecnologia.


**Como**

* Promovendo meetups (encontros) e mentorias. 

* Garantindo espaço amigável e seguro. 

---
class:  center

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="img/rladies_vix.png" alt="&amp;lt;center&amp;gt;&amp;lt;b&amp;gt; &amp;lt;/center&amp;gt;&amp;lt;/b&amp;gt;" width="40%" /&gt;
&lt;p class="caption"&gt;&lt;center&gt;&lt;b&gt; &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/div&gt;

O Capítulo da cidade de Vitória foi criado em 29 de setembro de 2019.



- [Código de conduta - R-Ladies](https://github.com/rladies/starter-kit/wiki/Code-of-Conduct#portuguese)


- Saiba mais:
  - RLadies Global: [https://rladies.org/](https://rladies.org/)
  - MeetUp: [https://www.meetup.com/pt-BR/R-Ladies-Vitoria](https://www.meetup.com/pt-BR/R-Ladies-Vitoria)
  - Twitter: [@RLadiesGlobal](https://twitter.com/rladiesglobal), [@rladiesvix](https://twitter.com/rladiesvix)
  - Instagram: [@RLadiesVix](http://instagram.com/rladiesvix)
  - Github: [https://github.com/rladies/meetup-presentations_vitoria](https://github.com/rladies/meetup-presentations_vitoria)


&lt;!-- R --&gt;
---
class: center


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="img/R_logo.svg.png" alt="&amp;lt;center&amp;gt;&amp;lt;b&amp;gt; &amp;lt;/center&amp;gt;&amp;lt;/b&amp;gt;" width="25%" /&gt;
&lt;p class="caption"&gt;&lt;center&gt;&lt;b&gt; &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/div&gt;


- O R é uma linguagem de programação, além de um ambiente de software gratuito. 

- oferece um vasto leque de funcionalidades acessíveis via instalação de bibliotecas.


- o R possui uma comunidade extremamente ativa, engajada desde o aprimoramento da ferramenta e desenvolvimento de novas bibliotecas, até o suporte aos usuários.


- Saiba mais em: [r-project.org](https://www.r-project.org/about.html) 




---
class: middle

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="img/rstudio.png" alt="&amp;lt;center&amp;gt;&amp;lt;b&amp;gt; &amp;lt;/center&amp;gt;&amp;lt;/b&amp;gt;" width="45%" /&gt;
&lt;p class="caption"&gt;&lt;center&gt;&lt;b&gt; &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/div&gt;
- Optar por programar em R também implica na escolha de uma IDE (Integrated Development Environment) que, na grande maioria dos casos, será o RStudio.

- O RStudio é um conjunto de ferramentas integradas projetadas (IDE - Integrated Development Environment) da linguagem R para editar e executar os códigos em R.

- O R, em combinação com o RStudio, possui um conjunto de funcionalidades cuja intenção é ajudar no processo de desenvolvimento.


- Saiba mais em: [https://rstudio.com/](https://rstudio.com/) 



---
class: middle

# RStudio

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="figures/rstudio1.png" alt="&amp;lt;center&amp;gt;&amp;lt;b&amp;gt; &amp;lt;/center&amp;gt;&amp;lt;/b&amp;gt;" width="100%" /&gt;
&lt;p class="caption"&gt;&lt;center&gt;&lt;b&gt; &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/div&gt;
---
class: middle

# RStudio


* Editor/Scripts: É onde escrever os códigos. Arquivos do tipo .R. 

* Console: Executar os comandos e ver os resultados. 

* Enviroment: Painel com todos os objetos criados.

* History: História dos comandos executados. 

* Files: Navegar em pastas e arquivos. 

* Plots: Onde os gráficos serão apresentados.

* Packages: Pacotes instalados (sem ticar) e habilitados (ticados). 

* Help: Retorna o tutorial de ajuda do comando solicitado com help() ou ?comando. Veremos melhor como pedir ajuda no R ainda nessa aula. 


---
class: middle

# Rproj e diretórios
- Organizar arquivos é uma parte integral do processo de programação.

- Denominados “projetos”, eles não passam de pastas comuns com um arquivo .Rproj.



Uma funcionalidade importante é a criação de projetos, permitindo dividir o trabalho em múltiplos ambientes, cada um com o seu diretório, documentos e workspace.

Para criar um projeto, os seguintes passos podem ser seguidos:

1) Clique na opção “File” do menu, e então em “New Project”.

2) Clique em “New Directory”.

3) Clique em “New Project”.

4) Escreva o nome do diretório (pasta) onde deseja manter seu projeto, ex “my_project”.

5) Clique no botão “Create Project”.

Para criar um novo script para escrever os códigos, vá em File -&gt; New File -&gt; R Script

---
class: middle

# Boas práticas

- Comente bem o seu código: É possível fazer comentários usando o símbolo ‘#’. É sempre bom explicar o que uma variável armazena, o que uma função faz, porque alguns parâmetros são passados para uma determinada função, qual é o objetivo de um trecho de código, etc.

- Evite linhas de código muito longas: Usar linhas de código mais curtas ajuda na leitura do código.

- Escreva um código organizado: Por exemplo, adote um padrão no uso de minúsculas e maiúsculas, uma lógica única na organização de pastas e arquivos, pode ser adotada uma breve descrição (como comentário) indicando o que um determinado script faz.

- Carregue todos os pacotes que irá usar sempre no início do arquivo: Quando alguém abrir o seu código será fácil identificar quais são os pacotes que devem ser instalados e quais dependências podem existir.

- Evite referência de caminho que considere seu computador ou usuário: Faça referência ao caminho do projeto.

---
class: middle

# Shall we?

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="img/allisonhorst/community1.jpg" alt="&amp;lt;center&amp;gt;&amp;lt;b&amp;gt;Ilustração por Allison Horst - Twitter: &amp;lt;a href='https://twitter.com/allison_horst/'&amp;gt; @allison_horst&amp;lt;/a&amp;gt; &amp;lt;/b&amp;gt;&amp;lt;/center&amp;gt;" width="40%" /&gt;
&lt;p class="caption"&gt;&lt;center&gt;&lt;b&gt;Ilustração por Allison Horst - Twitter: &lt;a href='https://twitter.com/allison_horst/'&gt; @allison_horst&lt;/a&gt; &lt;/b&gt;&lt;/center&gt;&lt;/p&gt;
&lt;/div&gt;

---
class: middle

### R como calculadora 

&lt;!-- 1) Operadores --&gt;


```r
#adição
10+15
  #&gt; [1] 25
#subtração
10-2
  #&gt; [1] 8
#multiplicação
2*10
  #&gt; [1] 20
#divisão
30/2
  #&gt; [1] 15
#raiz quadrada
sqrt(4)
  #&gt; [1] 2
#potência
2^2
  #&gt; [1] 4
```
Se você digitar um comando incompleto, como 10 *, o R mostrará um +. Isso não tem a ver com a soma e apenas que o R está esperando você completar seu comando. Termine seu comando ou aperte Esc para recomeçar. 
&lt;!-- Vale também ressaltar que se você digitar um comando que o R não reconhece, ele retornará uma mensagem de erro e você pode digitar outro comando normalmente em seguida.  --&gt;

---
class: middle

### Atribuição 

Para atribuir a um objeto, o sinal de atribuição é = ou &lt;-. 
Exemplos:

```r
x &lt;- 10/2
x
  #&gt; [1] 5
X
  #&gt; Error in eval(expr, envir, enclos): objeto 'X' não encontrado
```
Por que tivemos um erro acima?

--

O R é case sensitive, isto é, faz a diferenciação entre as letras minúsculas e maiúsculas. Portanto, x é diferente de X. 

---
class: middle

### Objetos em R

Existem cinco classes básicas no R:

* character: "UAH!" 

* numeric: 0.95 (números reais)

* integer: 100515 (inteiros)

* complex: 2 + 5i (números complexos, a + bi)

* logical: TRUE (booleanos, TRUE/FALSE)

---
class: middle

Vamos atribuir a x a string banana. 

```r
x &lt;- banana 
  #&gt; Error in eval(expr, envir, enclos): objeto 'banana' não encontrado
x &lt;- "banana"
x
  #&gt; [1] "banana"
```
O primeiro caso (x&lt;-banana) não deu certo, pois ele entendeu que estamos atribuindo a x outro objeto banana, que não foi declarado. Para atribuir o string banana à x, precisamos colocar entre aspas ou aspas simples. Uma string sem aspas é entendido como um objeto, veja abaixo:

```r
banana &lt;- 30
x &lt;- banana
x
  #&gt; [1] 30
```


---
class: middle

Função class().


```r
y &lt;- "ola"
class(y)
  #&gt; [1] "character"

x &lt;- 2.5
class(x)
  #&gt; [1] "numeric"
```

Apagar objetos


```r
x &lt;- 20
x
  #&gt; [1] 20
remove(x)
x
  #&gt; Error in eval(expr, envir, enclos): objeto 'x' não encontrado
```

E se eu quiser limpar o console - apaga todos os objetos atribuidos até aqui:

```r
rm(list=ls())
```

---
class: middle

### Data Strutures
* atomic vector

* matrix

* factors

* data frame

* list
---
class: middle

### Vetor
 &lt;!-- Como atribuir varios valores a um objeto?  Para entrar com vários números (ou nomes, ou qualquer outro grupo de coisas), precisamos usar uma função para dizer ao programa que os valores serão combinados em um único vetor. --&gt;

```r
x &lt;- c(2,3,4)
x
  #&gt; [1] 2 3 4
y &lt;- seq(1:10)
y
  #&gt;  [1]  1  2  3  4  5  6  7  8  9 10
z &lt;- rep(1,10)
z
  #&gt;  [1] 1 1 1 1 1 1 1 1 1 1
a &lt;- 1:10
a
  #&gt;  [1]  1  2  3  4  5  6  7  8  9 10
bicho &lt;-c("macaco","pato","galinha","porco")
bicho
  #&gt; [1] "macaco"  "pato"    "galinha" "porco"
```
E se quisermos visualizar o conteúdo da posição 2 no vetor bicho?

```r
bicho[2]
  #&gt; [1] "pato"
```


---
class: middle

Operações vetoriais


```r
k &lt;- x*2
y &lt;- c(x,k)
y
  #&gt; [1] 2 3 4 4 6 8
```
&lt;!-- Vale mencionar que o separador de decimais no R é . (ponto)!  --&gt;

Como calcularia o IMC de 6 pessoas?
--


```r
peso &lt;- c(62, 70, 52, 98, 90, 70)
altura &lt;- c(1.70, 1.82, 1.75, 1.94, 1.84, 1.61)
imc &lt;- peso/(altura^2)
imc
  #&gt; [1] 21.45329 21.13271 16.97959 26.03890 26.58318 27.00513
```

Função length(). 

```r
length(imc)
  #&gt; [1] 6
```

---
class: middle

### Matrizes

```r
x &lt;- matrix(seq(1:16), nrow=4,ncol=4)
x
  #&gt;      [,1] [,2] [,3] [,4]
  #&gt; [1,]    1    5    9   13
  #&gt; [2,]    2    6   10   14
  #&gt; [3,]    3    7   11   15
  #&gt; [4,]    4    8   12   16
x[2,3] #retorna o elemento na segunda linha e terceira coluna da matriz
  #&gt; [1] 10
x[3,  ]   # seleciona a 3ª linha
  #&gt; [1]  3  7 11 15
x[ , 2]   # seleciona a 2ª coluna
  #&gt; [1] 5 6 7 8
x[1,] &lt;- c(13,15,19,30)  #substituir a primeira linha por (13,15,19,30)

x
  #&gt;      [,1] [,2] [,3] [,4]
  #&gt; [1,]   13   15   19   30
  #&gt; [2,]    2    6   10   14
  #&gt; [3,]    3    7   11   15
  #&gt; [4,]    4    8   12   16
```
dimensao da matriz x?

```r
dim(x)
  #&gt; [1] 4 4
```
---
class: middle

Concatenar linhas em uma matriz

```r
vet &lt;- c(2,20,12,34)
x2 &lt;- rbind(x,vet)
x2
  #&gt;     [,1] [,2] [,3] [,4]
  #&gt;       13   15   19   30
  #&gt;        2    6   10   14
  #&gt;        3    7   11   15
  #&gt;        4    8   12   16
  #&gt; vet    2   20   12   34
```

Concatenar colunas em uma matriz

```r
v2 &lt;- c(25,10,15,4) 
x3 &lt;- cbind(x,v2)
x3
  #&gt;                  v2
  #&gt; [1,] 13 15 19 30 25
  #&gt; [2,]  2  6 10 14 10
  #&gt; [3,]  3  7 11 15 15
  #&gt; [4,]  4  8 12 16  4
```



---
class: middle

Operações matriciais

```r
xa &lt;- x2[1:2,1:2]
xb &lt;- matrix(rnorm(4),2,2)
xa*xb #multiplicacao ponto a ponto
  #&gt;       [,1]      [,2]
  #&gt;  -7.046730 -2.602730
  #&gt;   1.492529 -8.130206
xa%*%xb #multiplicacao matricial
  #&gt;      [,1]       [,2]
  #&gt;  4.147240 -22.581214
  #&gt;  3.393476  -8.477236
solve(xa) #inversa de xa
  #&gt;                            
  #&gt; [1,]  0.12500000 -0.3125000
  #&gt; [2,] -0.04166667  0.2708333
diag(xa) #matriz diagonal
  #&gt; [1] 13  6
```

---
class: middle

### Data frame
Trata-se de uma “tabela de dados” onde as colunas são as variáveis e as linhas são os registros. Essas colunas podem ser de classes diferentes. 
Essa é a grande diferença entre data.frame’s e matrizes (matriz é só numerica).

Posso criar um data frame no R com os vetores, por exemplo:

```r
ID &lt;- seq(1:6)
pes &lt;- c(62, 70, 52, 98, 90, 70)
alt &lt;- c(1.70, 1.82, 1.75, 1.94, 1.84, 1.61)
imc &lt;- pes/(alt^2)
dados &lt;- data.frame(ID=ID,peso=pes,altura=alt, imc=imc)
dados
  #&gt;   ID peso altura      imc
  #&gt; 1  1   62   1.70 21.45329
  #&gt; 2  2   70   1.82 21.13271
  #&gt; 3  3   52   1.75 16.97959
  #&gt; 4  4   98   1.94 26.03890
  #&gt; 5  5   90   1.84 26.58318
  #&gt; 6  6   70   1.61 27.00513
```

---
class: middle

Selecionar a variavel de interesse:

```r
dados$altura
  #&gt; [1] 1.70 1.82 1.75 1.94 1.84 1.61
```

Putz, esqueci de colocar a varivel de grupo no data frame. Tenho que criar tudo de novo? Não:

```r
gr &lt;- c(rep(1,3),rep(2,3))
dados$grupo &lt;- gr

dados
  #&gt;   ID peso altura      imc grupo
  #&gt; 1  1   62   1.70 21.45329     1
  #&gt; 2  2   70   1.82 21.13271     1
  #&gt; 3  3   52   1.75 16.97959     1
  #&gt; 4  4   98   1.94 26.03890     2
  #&gt; 5  5   90   1.84 26.58318     2
  #&gt; 6  6   70   1.61 27.00513     2
```

---
class: middle

Funcoes uteis para data.frame:

* head() - Mostra as primeiras 6 linhas.

* tail() - Mostra as últimas 6 linhas.

* dim() - Número de linhas e de colunas.

* names() - Os nomes das colunas (variáveis).

* str() - Estrutura do data.frame. Mostra, entre outras coisas, as classes de cada coluna.



```r
names(dados)
  #&gt; [1] "ID"     "peso"   "altura" "imc"    "grupo"
str(dados)
  #&gt; 'data.frame':	6 obs. of  5 variables:
  #&gt;  $ ID    : int  1 2 3 4 5 6
  #&gt;  $ peso  : num  62 70 52 98 90 70
  #&gt;  $ altura: num  1.7 1.82 1.75 1.94 1.84 1.61
  #&gt;  $ imc   : num  21.5 21.1 17 26 26.6 ...
  #&gt;  $ grupo : num  1 1 1 2 2 2
```

---
class: middle


```r
mean(dados$imc)
  #&gt; [1] 23.1988
sd(dados$imc)
  #&gt; [1] 4.00006
summary(dados$imc)
  #&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  #&gt;   16.98   21.21   23.75   23.20   26.45   27.01
```


```r
table(dados$grupo)
  #&gt; 
  #&gt; 1 2 
  #&gt; 3 3
```

---
class: middle

### Fator
&lt;!-- Fatores podem ser vistos como vetores de inteiros que possuem rótulos (labels). Eles são úteis para representar uma variável categórica (nominal e ordinal). --&gt;


```r
sexo &lt;- c("M", "H", "H", "H", "M", "M", "H")
sex &lt;- as.factor(sexo)
sex
  #&gt; [1] M H H H M M H
  #&gt; Levels: H M
levels(sex)
  #&gt; [1] "H" "M"
```

---
class: middle

### Arrays

```r
dim3 &lt;- array(rnorm(18),dim = c(3,3,2))
dim3
  #&gt; , , 1
  #&gt; 
  #&gt;           [,1]       [,2]       [,3]
  #&gt; [1,] 0.9840083 -0.2683370  0.6112624
  #&gt; [2,] 1.2859496  0.4086809  0.2887705
  #&gt; [3,] 1.5408799 -0.7550951 -1.0556964
  #&gt; 
  #&gt; , , 2
  #&gt; 
  #&gt;             [,1]       [,2]       [,3]
  #&gt; [1,]  1.15302413  0.5736745 -0.6950257
  #&gt; [2,] -0.14373441 -1.6844952 -0.5409261
  #&gt; [3,]  0.07872152  0.6148997 -1.4923401
```

---
class: middle

### Lists

```r
ls &lt;- list(ls1 = 'a',ls2 = c(1,2,3),ls3 = array(rnorm(6),dim = c(3,1,2,1)))
ls
  #&gt; $ls1
  #&gt; [1] "a"
  #&gt; 
  #&gt; $ls2
  #&gt; [1] 1 2 3
  #&gt; 
  #&gt; $ls3
  #&gt; , , 1, 1
  #&gt; 
  #&gt;            [,1]
  #&gt; [1,]  0.7708921
  #&gt; [2,] -0.1031338
  #&gt; [3,] -1.2210228
  #&gt; 
  #&gt; , , 2, 1
  #&gt; 
  #&gt;            [,1]
  #&gt; [1,] -0.9658463
  #&gt; [2,]  0.6058924
  #&gt; [3,] -0.5521938
```

---
class: middle

## Operadores Relacionais
Igual a: ==


```r
10==11
  #&gt; [1] FALSE
```

Diferente de: !=


```r
10!=11
  #&gt; [1] TRUE
```

* Maior que: &gt; 

* Maior ou igual: &gt;= 

* Menor que: &lt; 

* Menor ou igual: &lt;= 

---
class: middle

## Operadores Lógicos

* E: &amp; - será verdadeiro se os dois forem TRUE


```r
x &lt;- 15
x &gt; 10 &amp; x &lt; 30
  #&gt; [1] TRUE

x &lt; 10 &amp; x &lt; 30
  #&gt; [1] FALSE
```

* OU: | - será verdadeiro se um dos dois for TRUE


```r
x &gt; 10 | x &gt; 30
  #&gt; [1] TRUE
```

* Negação: ! 


```r
x &lt;- 15
!x&lt;30
  #&gt; [1] FALSE
```

---
class: middle

### If e else


```r
a &lt;- 224
b &lt;- 225
if (a==b) { v=10
} else {v=15}
v
  #&gt; [1] 15
```


```r
a &lt;- 224
b &lt;- 225
if (a==b) { v=10
} else if (a &gt; b) {v=15
} else {v=25}
v
  #&gt; [1] 25
```
Note que a condição de igualdade é representada por dois iguais ==. Como dito anteriormente, apenas um igual = é símbolo de atribuição. 

---
class: middle

### For

```r
m &lt;- c(1,20,50,60,100)
```
Quero criar um novo vetor, p digamos,  que seja formado por cada elemento 
de m dividido por sua posição. 

```r
p &lt;- rep(0,length(m))
for (i in 1: length(m)){
  p[i] &lt;- m[i]/i
}
p
  #&gt; [1]  1.00000 10.00000 16.66667 15.00000 20.00000
```
Note que primeiro definimos o objeto p. 

---
class: middle

### Funções 

```r
f.soma &lt;- function(x,y) {
  out &lt;- x+y
  return(out)
}
```
 * o nome: f.soma;
 
 * os argumentos: x e y;
 
 * o corpo out &lt;- x+y  e
 
 * o que retorna return(out).

Vamos agora chamar a função:

```r
f.soma(x=10,y=20)
  #&gt; [1] 30

f.soma(10,20)
  #&gt; [1] 30
```

---
class: middle

## Dados faltantes, infinitos e indefinições matemáticas

* NA (Not Available): dado faltante/indisponível. 

* NaN (Not a Number): indefinições matemáticas. Como 0/0 e log(-1).

* Inf (Infinito): número muito grande ou o limite matemático. Aceita sinal negativo -Inf.


---
class: middle

### Como obter ajuda no R

  * Help/documentação do R 

```r
help(mean) #ou
?mean
```

* Google.
&lt;img src="figures/help_R.png" width="60%" style="display: block; margin: auto;" /&gt;

* Comunidade.

[Stack Overflow](https://stackoverflow.com/) e o [Stack Overflow em Português](https://pt.stackoverflow.com/). 


---
##Adicionando GIFS


```r
knitr::include_graphics("https://media2.giphy.com/media/S857VNxM6HwlZuYXrU/giphy.gif")
```

&lt;img src="https://media2.giphy.com/media/S857VNxM6HwlZuYXrU/giphy.gif" width="50%" style="display: block; margin: auto;" /&gt;


---
class: middle


## Pacotes

### Instalação

* Via CRAN: install.packages("nome-do-pacote").

install.packages("tidyverse")

Note que o nome do pacote está entre aspas. 

* Via Github: devtools::install_github("nome-do-repo/nome-do-pacote").

devtools::install_github("tidyverse/dplyr")

### Carregar pacotes:

library(nome-do-pacote)

Para carregar o pacote, não usar aspas.

Só é necessário instalar o pacote uma vez, mas precisa carregá-lo toda vez que começar uma nova sessão.



---
class: middle

# Importação de dados

## Extensão .txt ou .csv

Opção com o pacote **readr**.


```r
library(readr) #pacote readr
dados_csv &lt;- read_csv(file = "dados1.csv")
dados_txt &lt;- read_delim(file = "caminho-para-o-arquivo/dados1.txt", delim = " ")
```

&lt;!-- O argumento file= representa o caminho onde o arquivo está alocado. Se o arquivo estiver no diretório de trabalho, não precisa especificar o caminho até o arquivo. O argumento delim= indica qual caracter separa cada coluna no arquivo de texto. --&gt;
 
Outra opção: 
&lt;!-- para leitura de arquivo .txt é usar a função read.table que já está salva na base, ou seja, não é necessário instalar pacote.  --&gt;


```r
dados_txt2 &lt;- read.table(file="dados1.txt",header=T)
```

&lt;!-- O argumento header indica se a primeira linha do arquivo consta o nome das variáveis. Se for T (TRUE), a primeira linha é indicada como nome das variáveis. O default é header=F.  --&gt;

Vale ressaltar que para cada função read_, existe uma respectiva função write_ para salvar o arquivo no formato de interesse. Como exemplo, queremos salvar a base de dados cars. 


```r
write_csv(x = mtcars, path = "cars.csv")
write_delim(x = mtcars, delim = " ", path = "cars.txt"))
```

---
class: middle

## Arquivos em Excel

O pacote **readxl** pode ser utilizado para leiturade arquivos do Excel, como .xls e xlsx.


```r
library(readxl)
dados_excel &lt;- read_xls(path = "dados1.xls") #Leitura do arquivo .xls
dados_excelx &lt;- read_xlsx(path = "dados1.xlsx") #Leitura do arquivo .xlsx
```

Uma maneira mais simples é a utilização da função read_excel(), pois ela auto detecta a extensão do arquivo.

```r
library(readxl)
dados_excel1 &lt;- read_excel(path = "dados1.xls")
dados_excelx1 &lt;- read_excel(path = "dados1.xlsx")
```



## Arquivos de outros softwares

&lt;!-- Para ler dados salvos em extensão de outros softwares: SPSS, STATA e SAS: pacote haven.  --&gt;


```r
library(haven)
dados_stata &lt;- read_stata("dados1.dta")
dados_spss &lt;- read_spss("dados1.sav")
dados_sas &lt;- read_sas("dados1.sas7bdat")  
```

&lt;!-- Outra opção de pacote para importação de dados de outros softwares é o foreign. Além do SAS, STAT e SPSS, ele também lê dados do Octave, Minitab e Epi Info.  --&gt;


---
class: middle

## Tratamento de dados

A análise de consistência consiste em realizar uma primeira análise dos dados com o intuito de encontrar inconsistências. 
* boas práticas para nome das variáveis. 
* identificar erros de digitação;
* indivíduos imputados mais de uma vez na planilha de dados de maneira errada; 
* identificar casos missings e avaliar se a observação está ausente de maneira correta ou não;
* identificar as categorias de variáveis qualitativas.

Consideramos como exemplo os dados fictícios de `\(n=30\)` gestações gemelares. Vamos considerar duas bases de dados. Na primeira, chamada de "Base_CTG_caracterizacao" estão contidas as informações de caracterização das gestantes e gestações. 

Para importar a base de dados: 

```r
library(readxl)
dados &lt;- read_excel(path = "Base_CTG_caracterizacao.xls",na="NA")
dados
  #&gt; # A tibble: 34 x 13
  #&gt;       ID CORION `Data aval`         `Data nascimento`   `COR BRANCO` `Peso Pré`
  #&gt;    &lt;dbl&gt; &lt;chr&gt;  &lt;dttm&gt;              &lt;dttm&gt;                     &lt;dbl&gt;      &lt;dbl&gt;
  #&gt;  1     1 Di     2017-04-23 00:00:00 1988-04-30 00:00:00            1         93
  #&gt;  2     2 Mono   2016-03-21 00:00:00 1982-03-30 00:00:00            1         59
  #&gt;  3     2 Mono   2016-03-21 00:00:00 1982-03-30 00:00:00            1         59
  #&gt;  4     3 Di     2016-02-17 00:00:00 1991-02-23 00:00:00            0         87
  #&gt;  5     4 Di     2017-12-14 00:00:00 1983-12-23 00:00:00            1         52
  #&gt;  6     5 Di     2017-04-23 00:00:00 1988-04-30 00:00:00            0         78
  #&gt;  7     6 Di     2016-03-21 00:00:00 1989-03-28 00:00:00            0         62
  #&gt;  8     7 Di     2016-02-17 00:00:00 1985-02-24 00:00:00            0         54
  #&gt;  9     8 Di     2017-12-14 00:00:00 1988-12-21 00:00:00            1         72
  #&gt; 10     9 Di     2017-04-23 00:00:00 1980-05-02 00:00:00            3         72
  #&gt; # ... with 24 more rows, and 7 more variables: ALT &lt;dbl&gt;, Gesta &lt;dbl&gt;,
  #&gt; #   Para &lt;dbl&gt;, Aborto &lt;dbl&gt;, `IGP semana` &lt;dbl&gt;, `IGP dia` &lt;dbl&gt;, oi &lt;lgl&gt;
```



---
class: middle

##Exercício

Na base em excel, retire os NA's, deixando em branco, e rode o seguinte comando:


```r
library(readxl)
dados &lt;- read_excel(path = "Base_CTG_caracterizacao.xls")
```
O default do missing é o espaço em branco. Acesse o help em ?read_excel e veja na = "".  

---
class: middle

###Nome das variáveis

Utilizaremos as funções tidyverse e janitor para a arrumação da base de dados. 



```r
library(tidyverse)
library(janitor)

names(dados)
  #&gt;  [1] "ID"              "CORION"          "Data aval"       "Data nascimento"
  #&gt;  [5] "COR BRANCO"      "Peso Pré"        "ALT"             "Gesta"          
  #&gt;  [9] "Para"            "Aborto"          "IGP semana"      "IGP dia"        
  #&gt; [13] "oi"
dados &lt;- clean_names(dados) # a função clean_names() para primeiro ajuste dos nomes das variaveis
names(dados)
  #&gt;  [1] "id"              "corion"          "data_aval"       "data_nascimento"
  #&gt;  [5] "cor_branco"      "peso_pre"        "alt"             "gesta"          
  #&gt;  [9] "para"            "aborto"          "igp_semana"      "igp_dia"        
  #&gt; [13] "oi"
```

---
class: middle

###Linhas e colunas vazias 
 Na base de dados em questão, não há linhas vazias, como pode ser visto na saída abaixo. 


```r
dados &lt;- remove_empty(dados,"rows")
```

Propositalmente, inclui a coluna "oi" vazia para podermos eliminá-la com o comando abaixo: 

```r
dados &lt;- remove_empty(dados,"cols")
names(dados)
  #&gt;  [1] "id"              "corion"          "data_aval"       "data_nascimento"
  #&gt;  [5] "cor_branco"      "peso_pre"        "alt"             "gesta"          
  #&gt;  [9] "para"            "aborto"          "igp_semana"      "igp_dia"
```

---
class: middle

### Identificação de casos duplicados

&lt;!-- Uma boa prática consiste em identificar casos duplicados, isto é, identificar se há casos erroneamente repetidos. No exemplo, a variável chave é id, em que cada indivíduo distinto apresenta um id distinto.  Para identificar casos duplicados pela variável chave "id", usamos a função get_dupes do pacote janitor.  --&gt;


```r
get_dupes(dados, id)
  #&gt; # A tibble: 8 x 13
  #&gt;      id dupe_count corion data_aval           data_nascimento     cor_branco
  #&gt;   &lt;dbl&gt;      &lt;int&gt; &lt;chr&gt;  &lt;dttm&gt;              &lt;dttm&gt;                   &lt;dbl&gt;
  #&gt; 1     2          2 Mono   2016-03-21 00:00:00 1982-03-30 00:00:00          1
  #&gt; 2     2          2 Mono   2016-03-21 00:00:00 1982-03-30 00:00:00          1
  #&gt; 3    11          2 Di     2016-02-17 00:00:00 1981-02-25 00:00:00          1
  #&gt; 4    11          2 Di     2016-02-17 00:00:00 1981-02-25 00:00:00          1
  #&gt; 5    17          2 Di     2017-04-23 00:00:00 1993-04-29 00:00:00          1
  #&gt; 6    17          2 Di     2017-04-23 00:00:00 1993-04-29 00:00:00          1
  #&gt; 7    23          2 Di     2016-02-17 00:00:00 1997-02-21 00:00:00          1
  #&gt; 8    23          2 Di     2016-02-17 00:00:00 1997-02-21 00:00:00          1
  #&gt; # ... with 7 more variables: peso_pre &lt;dbl&gt;, alt &lt;dbl&gt;, gesta &lt;dbl&gt;,
  #&gt; #   para &lt;dbl&gt;, aborto &lt;dbl&gt;, igp_semana &lt;dbl&gt;, igp_dia &lt;dbl&gt;
```
&lt;!-- No exemplo, note que os IDs=2, 11, 17 e 23 aparecem dois casos cada, o que não está correto para essa aplicação.  --&gt;
&lt;!-- Para eliminar linhas duplicadas identificadas, usamos a função distinct do pacote dplyr. No objeto dados1 salvamos os dados sem os casos duplicados.  --&gt;

```r
library(dplyr)
dados1 &lt;-  distinct(dados,id, .keep_all = TRUE)
dados1
  #&gt; # A tibble: 30 x 12
  #&gt;       id corion data_aval           data_nascimento     cor_branco peso_pre
  #&gt;    &lt;dbl&gt; &lt;chr&gt;  &lt;dttm&gt;              &lt;dttm&gt;                   &lt;dbl&gt;    &lt;dbl&gt;
  #&gt;  1     1 Di     2017-04-23 00:00:00 1988-04-30 00:00:00          1       93
  #&gt;  2     2 Mono   2016-03-21 00:00:00 1982-03-30 00:00:00          1       59
  #&gt;  3     3 Di     2016-02-17 00:00:00 1991-02-23 00:00:00          0       87
  #&gt;  4     4 Di     2017-12-14 00:00:00 1983-12-23 00:00:00          1       52
  #&gt;  5     5 Di     2017-04-23 00:00:00 1988-04-30 00:00:00          0       78
  #&gt;  6     6 Di     2016-03-21 00:00:00 1989-03-28 00:00:00          0       62
  #&gt;  7     7 Di     2016-02-17 00:00:00 1985-02-24 00:00:00          0       54
  #&gt;  8     8 Di     2017-12-14 00:00:00 1988-12-21 00:00:00          1       72
  #&gt;  9     9 Di     2017-04-23 00:00:00 1980-05-02 00:00:00          3       72
  #&gt; 10    10 Di     2016-03-21 00:00:00 1984-03-29 00:00:00          1      102
  #&gt; # ... with 20 more rows, and 6 more variables: alt &lt;dbl&gt;, gesta &lt;dbl&gt;,
  #&gt; #   para &lt;dbl&gt;, aborto &lt;dbl&gt;, igp_semana &lt;dbl&gt;, igp_dia &lt;dbl&gt;
```
&lt;!-- Ao chamar os dados1,  apenas as dez primeiras linhas são impressas na tela e as colunas que não couberem na largura do console serão omitidas. Vale ressaltar que também são apresentadas a dimensão da tabela (no exemplo, 30X12) e as classes de cada coluna. --&gt;

---
class: middle


### Identificar tipo e classe de todas as variáveis da base
Para identificar a classe de todas as variáveis que o R está interpretando, usamos a função str(.).  


```r
# Ver a estrutura dos dados
str(dados1)
  #&gt; Classes 'tbl_df', 'tbl' and 'data.frame':	30 obs. of  12 variables:
  #&gt;  $ id             : num  1 2 3 4 5 6 7 8 9 10 ...
  #&gt;  $ corion         : chr  "Di" "Mono" "Di" "Di" ...
  #&gt;  $ data_aval      : POSIXct, format: "2017-04-23" "2016-03-21" ...
  #&gt;  $ data_nascimento: POSIXct, format: "1988-04-30" "1982-03-30" ...
  #&gt;  $ cor_branco     : num  1 1 0 1 0 0 0 1 3 1 ...
  #&gt;  $ peso_pre       : num  93 59 87 52 78 62 54 72 72 102 ...
  #&gt;  $ alt            : num  1.63 1.45 1.69 1.55 1.59 1.64 NA 1.64 1.65 1.68 ...
  #&gt;  $ gesta          : num  3 3 2 2 7 7 2 2 8 3 ...
  #&gt;  $ para           : num  1 1 1 0 2 4 1 1 4 2 ...
  #&gt;  $ aborto         : num  1 1 0 1 4 2 0 0 3 0 ...
  #&gt;  $ igp_semana     : num  37 37 35 38 38 29 38 34 36 37 ...
  #&gt;  $ igp_dia        : num  4 3 0 1 3 3 3 6 3 5 ...
```




```r
dados1$data_aval  &lt;- as.Date(dados1$data_aval)
dados1$data_nascimento  &lt;- as.Date(dados1$data_nascimento)
str(dados1)
  #&gt; Classes 'tbl_df', 'tbl' and 'data.frame':	30 obs. of  12 variables:
  #&gt;  $ id             : num  1 2 3 4 5 6 7 8 9 10 ...
  #&gt;  $ corion         : chr  "Di" "Mono" "Di" "Di" ...
  #&gt;  $ data_aval      : Date, format: "2017-04-23" "2016-03-21" ...
  #&gt;  $ data_nascimento: Date, format: "1988-04-30" "1982-03-30" ...
  #&gt;  $ cor_branco     : num  1 1 0 1 0 0 0 1 3 1 ...
  #&gt;  $ peso_pre       : num  93 59 87 52 78 62 54 72 72 102 ...
  #&gt;  $ alt            : num  1.63 1.45 1.69 1.55 1.59 1.64 NA 1.64 1.65 1.68 ...
  #&gt;  $ gesta          : num  3 3 2 2 7 7 2 2 8 3 ...
  #&gt;  $ para           : num  1 1 1 0 2 4 1 1 4 2 ...
  #&gt;  $ aborto         : num  1 1 0 1 4 2 0 0 3 0 ...
  #&gt;  $ igp_semana     : num  37 37 35 38 38 29 38 34 36 37 ...
  #&gt;  $ igp_dia        : num  4 3 0 1 3 3 3 6 3 5 ...
```


---
class: middle


### Identificar tipo e classe de todas as variáveis da base

Utilizamos a função as.Date(.) porque queríamos mudar para tipo data. Abaixo está a lista das funções para mudança de tipo.

* as.character -  converte para variável texto.

* as.numeric - converte para variável número.

* as.factor - converte para variável categórica.

* as.integer - converte para variável inteiro.

* as.Date - converte para variável data.

* as.POSIXct - converte para variável data e hora completa. 


---
class:  middle

### Identificar erros
Para variáveis qualitativas: tabela de frequências da variável corion. 


```r
#do pacote janitor
tabyl(dados1,corion) 
  #&gt;  corion  n    percent
  #&gt;      Di 25 0.83333333
  #&gt;      DI  1 0.03333333
  #&gt;    Mono  3 0.10000000
  #&gt;    MONO  1 0.03333333
```

Para lidar com variáveis de texto, vamos utilizar a função str_to_lower do pacote stringr.


```r

library(stringr)
dados1$corion &lt;- str_to_lower(dados1$corion)
tabyl(dados1,corion)
  #&gt;  corion  n   percent
  #&gt;      di 26 0.8666667
  #&gt;    mono  4 0.1333333
```

---
class: middle

A variável indicadora de cor branca (cor_branco) está categorizada como 0 para não e 1 para sim.  

```r
tabyl(dados1,cor_branco) 
  #&gt;  cor_branco  n    percent
  #&gt;           0 12 0.40000000
  #&gt;           1 17 0.56666667
  #&gt;           3  1 0.03333333
```



```r
dados1$cor_branco &lt;- ifelse(dados1$id==9,1,dados1$cor_branco)
```

No R tem um pacote só para manipular fatores: o **forcats** (for categorial variables). 

Primeiro, precisamos informar o R que a variável é fator, com o comando as.factor(.).

```r
library(forcats)
dados1$cor_branco  &lt;- as.factor(dados1$cor_branco)

dados1$cor_branco &lt;- fct_recode(dados1$cor_branco,
           branco = "1", 
           nbranco = "0")

tabyl(dados1,cor_branco)
  #&gt;  cor_branco  n percent
  #&gt;     nbranco 12     0.4
  #&gt;      branco 18     0.6
```
---
class: middle

Para fazer análise geral de todas as variáveis da base de dados, usamos a função skim(.) do pacote **skimr**. 

```r
library(skimr)
kable(skim(dados1)) 
  #&gt; Skim summary statistics  
  #&gt;  n obs: 30    
  #&gt;  n variables: 12    
  #&gt; 
  #&gt; Variable type: character
  #&gt; 
  #&gt;  variable    missing    complete    n     min    max    empty    n_unique 
  #&gt; ----------  ---------  ----------  ----  -----  -----  -------  ----------
  #&gt;   corion        0          30       30     2      4       0         2     
  #&gt; 
  #&gt; Variable type: Date
  #&gt; 
  #&gt;     variable        missing    complete    n        min           max          median      n_unique 
  #&gt; -----------------  ---------  ----------  ----  ------------  ------------  ------------  ----------
  #&gt;     data_aval          0          30       30    2016-02-17    2017-12-14    2016-10-06       4     
  #&gt;  data_nascimento       0          30       30    1980-02-26    1998-12-19    1988-04-30       23    
  #&gt; 
  #&gt; Variable type: factor
  #&gt; 
  #&gt;   variable     missing    complete    n     n_unique          top_counts           ordered 
  #&gt; ------------  ---------  ----------  ----  ----------  -------------------------  ---------
  #&gt;  cor_branco       0          30       30       2        bra: 18, nbr: 12, NA: 0     FALSE  
  #&gt; 
  #&gt; Variable type: numeric
  #&gt; 
  #&gt;   variable     missing    complete    n     mean      sd       p0     p25     p50      p75     p100      hist   
  #&gt; ------------  ---------  ----------  ----  -------  -------  ------  ------  ------  -------  ------  ----------
  #&gt;    aborto         0          30       30     0.5     1.01      0       0       0      0.75      4      &lt;U+2587&gt;&lt;U+2582&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt; 
  #&gt;     alt           1          29       30    1.61     0.073    1.45    1.56    1.62    1.64     1.76    &lt;U+2582&gt;&lt;U+2581&gt;&lt;U+2583&gt;&lt;U+2583&gt;&lt;U+2587&gt;&lt;U+2582&gt;&lt;U+2582&gt;&lt;U+2582&gt; 
  #&gt;    gesta          0          30       30    2.57     2.01      1       1       2        3       8      &lt;U+2587&gt;&lt;U+2585&gt;&lt;U+2583&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt; 
  #&gt;      id           0          30       30    15.5      8.8      1      8.25    15.5    22.75     30     &lt;U+2587&gt;&lt;U+2587&gt;&lt;U+2586&gt;&lt;U+2587&gt;&lt;U+2587&gt;&lt;U+2586&gt;&lt;U+2587&gt;&lt;U+2587&gt; 
  #&gt;   igp_dia         0          30       30      3      1.62      0       2       3        3       6      &lt;U+2581&gt;&lt;U+2582&gt;&lt;U+2583&gt;&lt;U+2587&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2582&gt; 
  #&gt;  igp_semana       0          30       30    35.73    2.27      29      35     36.5     37       38     &lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2582&gt;&lt;U+2582&gt;&lt;U+2582&gt;&lt;U+2587&gt; 
  #&gt;     para          0          30       30    1.07     1.26      0       0       1      1.75      4      &lt;U+2587&gt;&lt;U+2586&gt;&lt;U+2581&gt;&lt;U+2582&gt;&lt;U+2581&gt;&lt;U+2582&gt;&lt;U+2581&gt;&lt;U+2581&gt; 
  #&gt;   peso_pre        1          29       30    68.34    16.23     44      55      66      78      102     &lt;U+2583&gt;&lt;U+2587&gt;&lt;U+2587&gt;&lt;U+2587&gt;&lt;U+2583&gt;&lt;U+2582&gt;&lt;U+2582&gt;&lt;U+2582&gt;
```
---
class: middle

### Transformação de variáveis quantitativas

Calcular IMC (índice de massa corpórea) - peso (em km) dividido pela altura (em metros) ao quadrado.


```r
dados1 &lt;- mutate(dados1,imc = peso_pre/(alt^2))
kable(skim(dados1,imc))
  #&gt; Skim summary statistics  
  #&gt;  n obs: 30    
  #&gt;  n variables: 13    
  #&gt; 
  #&gt; Variable type: numeric
  #&gt; 
  #&gt;  variable    missing    complete    n     mean     sd      p0       p25      p50      p75     p100       hist   
  #&gt; ----------  ---------  ----------  ----  ------  ------  -------  -------  -------  -------  -------  ----------
  #&gt;    imc          2          28       30    26.6    5.95    16.36    22.12    25.97    29.32    40.69    &lt;U+2581&gt;&lt;U+2587&gt;&lt;U+2586&gt;&lt;U+2587&gt;&lt;U+2583&gt;&lt;U+2581&gt;&lt;U+2582&gt;&lt;U+2582&gt;
str(dados1)
  #&gt; Classes 'tbl_df', 'tbl' and 'data.frame':	30 obs. of  13 variables:
  #&gt;  $ id             : num  1 2 3 4 5 6 7 8 9 10 ...
  #&gt;  $ corion         : chr  "di" "mono" "di" "di" ...
  #&gt;  $ data_aval      : Date, format: "2017-04-23" "2016-03-21" ...
  #&gt;  $ data_nascimento: Date, format: "1988-04-30" "1982-03-30" ...
  #&gt;  $ cor_branco     : Factor w/ 2 levels "nbranco","branco": 2 2 1 2 1 1 1 2 2 2 ...
  #&gt;  $ peso_pre       : num  93 59 87 52 78 62 54 72 72 102 ...
  #&gt;  $ alt            : num  1.63 1.45 1.69 1.55 1.59 1.64 NA 1.64 1.65 1.68 ...
  #&gt;  $ gesta          : num  3 3 2 2 7 7 2 2 8 3 ...
  #&gt;  $ para           : num  1 1 1 0 2 4 1 1 4 2 ...
  #&gt;  $ aborto         : num  1 1 0 1 4 2 0 0 3 0 ...
  #&gt;  $ igp_semana     : num  37 37 35 38 38 29 38 34 36 37 ...
  #&gt;  $ igp_dia        : num  4 3 0 1 3 3 3 6 3 5 ...
  #&gt;  $ imc            : num  35 28.1 30.5 21.6 30.9 ...
```

---
class: middle

##Exercício
Crie a variável igp (idade gestacional do parto) em semanas - obtida ao somar igp_semana e igp_dia/7. 

---
class: middle

## Transformação de variáveis qualitativas

A variável "gesta" indica o número de gestações, contando com a atual. Logo, uma gestante com gesta=1 está em sua primeira gestação, ou seja, é primigesta. Queremos criar uma nova variável indicadora de gestação primigesta. Há diferentes forma de fazer isso. Vamos usar o comando ifelse já utilizado anteriormente. 


```r
dados1$primigesta &lt;- ifelse(dados1$para==1,1,0)
tabyl(dados1,primigesta) 
  #&gt;  primigesta  n percent
  #&gt;           0 21     0.7
  #&gt;           1  9     0.3
```
Agora vamos recodificar primigesta com o nome de cada categoria: 

```r
dados1$primigesta &lt;- as.factor(dados1$primigesta)
dados1$primigesta &lt;- fct_recode(dados1$primigesta,
           nao = "0", 
           sim = "1")
tabyl(dados1,primigesta) 
  #&gt;  primigesta  n percent
  #&gt;         nao 21     0.7
  #&gt;         sim  9     0.3
```

---
class: middle

##Exercício:

1) Crie a variável indicador_aborto (sim e nao) - sim se aborto &gt;=1 e nao se aborto=0. 

2) Crie a variável primipara (sim e nao) - sim se para &gt;=1 e nao se para=0. 


---
class: middle

### Diferença de datas
Vamos calcular a idade das pacientes (data da avaliação e data do nascimento). Para realizar operações com data, usaremos o pacote **lubridate**. 

A data está salva no formato ano-mês-dia e por isso usamos a função ymd(.) para as variáveis de data. Para calcular a diferença entre as data, usamos a função `\(%--%\)`, atribuindo ao objeto intervalo. Por fim, obtemos a idade ao dividir o intervalo por ano.  

```r
library(lubridate)
intervalo &lt;- ymd(dados1$data_nascimento) %--%  ymd(dados1$data_aval)

dados1$idade &lt;- intervalo / dyears(1)  #número de anos

kable(skim(dados1,idade))
  #&gt; Skim summary statistics  
  #&gt;  n obs: 30    
  #&gt;  n variables: 15    
  #&gt; 
  #&gt; Variable type: numeric
  #&gt; 
  #&gt;  variable    missing    complete    n     mean     sd     p0     p25     p50     p75     p100      hist   
  #&gt; ----------  ---------  ----------  ----  ------  ------  ----  -------  -----  -------  ------  ----------
  #&gt;   idade         0          30       30    27.9    6.05    18    23.25    29     33.75     37     &lt;U+2587&gt;&lt;U+2583&gt;&lt;U+2586&gt;&lt;U+2583&gt;&lt;U+2587&gt;&lt;U+2585&gt;&lt;U+2586&gt;&lt;U+2587&gt;
```
&lt;!-- Vale ressaltar que há várias funções importantes para lidar com variáveis de data no pacote lubridate. Para mais detalhes, ver o [vignette](https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html). --&gt;

---
class: middle

### Combinação de bases de dados

Agora vamos considerar a segunda base de dados. Essa base de dados contém novas variáveis para os mesmos `\(n=30\)` gestantes, identificadas pela variável chave "id". 
Vamos então ler a base de dados, atribuindo para o objeto "dados.ctg".

```r
dados.ctg &lt;- read_excel(path = "Base_CTG_NumContraeColo.xls")

str(dados.ctg)
  #&gt; Classes 'tbl_df', 'tbl' and 'data.frame':	30 obs. of  5 variables:
  #&gt;  $ ID            : num  1 2 3 4 5 6 7 8 9 10 ...
  #&gt;  $ Grupo         : num  2 1 1 1 2 1 2 1 1 2 ...
  #&gt;  $ IG_Aval       : num  33.7 33.4 30.9 33 32.9 ...
  #&gt;  $ MedidaColo    : num  33 34.6 25 27 32.8 20.6 33.1 28 21.8 46.3 ...
  #&gt;  $ Num_contra_CTG: num  9 4 5 6 5 2 1 3 2 8 ...
```

---
class: middle


##EXERCÍCIO: 
Realize o tratamento da base de dados "dados.ctg". 


---
class: middle

Há algumas funções de combinação de duas bases de dados no pacote **dplyr**. Aqui estão as mais úteis:

* inner_join () - retorna valores de ambas as tabelas somente onde há uma correspondência.

* left_join () - retorna todos os valores da primeira tabela mencionada, mais os da segunda tabela correspondente.

* semi_join () - filtra a primeira tabela mencionada para incluir apenas os valores que possuem correspondências na segunda tabela.

* anti_join () - filtra a primeira tabela mencionada para incluir apenas valores que não possuem correspondências na segunda tabela.

---
class: middle


```r
dados.todos &lt;- inner_join(dados1, dados.ctg, by=c("id" = "ID"))

dados.todos
  #&gt; # A tibble: 30 x 19
  #&gt;       id corion data_aval  data_nascimento cor_branco peso_pre   alt gesta  para
  #&gt;    &lt;dbl&gt; &lt;chr&gt;  &lt;date&gt;     &lt;date&gt;          &lt;fct&gt;         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
  #&gt;  1     1 di     2017-04-23 1988-04-30      branco           93  1.63     3     1
  #&gt;  2     2 mono   2016-03-21 1982-03-30      branco           59  1.45     3     1
  #&gt;  3     3 di     2016-02-17 1991-02-23      nbranco          87  1.69     2     1
  #&gt;  4     4 di     2017-12-14 1983-12-23      branco           52  1.55     2     0
  #&gt;  5     5 di     2017-04-23 1988-04-30      nbranco          78  1.59     7     2
  #&gt;  6     6 di     2016-03-21 1989-03-28      nbranco          62  1.64     7     4
  #&gt;  7     7 di     2016-02-17 1985-02-24      nbranco          54 NA        2     1
  #&gt;  8     8 di     2017-12-14 1988-12-21      branco           72  1.64     2     1
  #&gt;  9     9 di     2017-04-23 1980-05-02      branco           72  1.65     8     4
  #&gt; 10    10 di     2016-03-21 1984-03-29      branco          102  1.68     3     2
  #&gt; # ... with 20 more rows, and 10 more variables: aborto &lt;dbl&gt;, igp_semana &lt;dbl&gt;,
  #&gt; #   igp_dia &lt;dbl&gt;, imc &lt;dbl&gt;, primigesta &lt;fct&gt;, idade &lt;dbl&gt;, Grupo &lt;dbl&gt;,
  #&gt; #   IG_Aval &lt;dbl&gt;, MedidaColo &lt;dbl&gt;, Num_contra_CTG &lt;dbl&gt;
```

---
class: middle

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="figures/pacotes_R_importantes.png" alt="&amp;lt;center&amp;gt;&amp;lt;b&amp;gt; &amp;lt;/center&amp;gt;&amp;lt;/b&amp;gt;" width="70%" /&gt;
&lt;p class="caption"&gt;&lt;center&gt;&lt;b&gt; &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/div&gt;
Imagem de [Curso-R](https://www.curso-r.com/material/)
---

class:  center, middle

## Obrigada!

![título](https://media.giphy.com/media/l3q2u6MXJJEKiTZIY/giphy.gif)

---

class:  center, middle

## Obrigada!

- Contato:

  - Website RLadies Global: [https://rladies.org/](https://rladies.org/)
  
  - MeetUp: [https://www.meetup.com/pt-BR/R-Ladies-Vitoria](https://www.meetup.com/pt-BR/R-Ladies-Vitoria)

  - Twitter: [@RLadiesGlobal](https://twitter.com/rladiesglobal), [@rladiesvix](https://twitter.com/rladiesvix)

  - Instagram: [@RLadiesVix](http://instagram.com/rladiesvix)

  - Github: [https://github.com/rladies/meetup-presentations_vitoria](https://github.com/rladies/meetup-presentations_vitoria)

  - Email: vitoria@rladies.org
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
