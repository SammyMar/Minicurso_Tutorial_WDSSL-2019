<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>R básico  </title>
    <meta charset="utf-8" />
    <meta name="author" content="     R-Ladies Vitória" />
    <script src="libs/header-attrs-2.25/header-attrs.js"></script>
    <link rel="stylesheet" href="css/kunoichi.css" type="text/css" />
    <link rel="stylesheet" href="css/ninjutsu.css" type="text/css" />
    <link rel="stylesheet" href="css/rladies-fonts.css" type="text/css" />
    <link rel="stylesheet" href="scrollable.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# R básico <br>
]
.subtitle[
## meus primeiros passos no R <br><br><br>
]
.author[
### <br><br><br><br> R-Ladies Vitória
]
.date[
### Novembro/2023
]

---

layout: true

&lt;!-- &lt;div class="my-footer"&gt;&lt;span&gt; --&gt;

&lt;!-- &lt;a href="https://www.meetup.com/pt-BR/R-Ladies-Vitoria"&gt;Meetup&lt;/a&gt; | --&gt;
&lt;!-- &lt;a href="https://twitter.com/rladiesvix"&gt;Twitter&lt;/a&gt; |  --&gt;
&lt;!-- &lt;a href="http://instagram.com/rladiesvix"&gt;Instagram&lt;/a&gt; | --&gt;
&lt;!-- &lt;a href="https://github.com/rladies/meetup-presentations_vitoria"&gt;Github&lt;/a&gt;  --&gt;


&lt;!-- &lt;/span&gt;&lt;/div&gt;  --&gt;



&lt;!-- programação --&gt;
---
class: middle 

# Programação
- Introdução ao R:
  - Ambiente e IDE, boas praticas e Aspectos Diversos.
- R Básico:
  - Pacotes, Tipos de Dados e Operadores, Estrutura de Dados, Funções, Ajuda, Importação de Dados
- Limpeza e Tratamento de Dados
  - TidyVerse e pacotes mais utilizados, detectação de inconsistências.
- Gráficos e Visualização
- Medidas descritivas


&lt;!-- R --&gt;
---
class: middle


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="img/R_logo.svg.png" alt="&lt;center&gt;&lt;b&gt; &lt;/center&gt;&lt;/b&gt;" width="20%" /&gt;
&lt;p class="caption"&gt;&lt;center&gt;&lt;b&gt; &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/div&gt;


- O R é uma linguagem de programação, além de um ambiente de software gratuito. 

- Oferece um vasto leque de funcionalidades acessíveis via instalação de bibliotecas.

- O R possui uma comunidade extremamente ativa, engajada desde o aprimoramento da ferramenta e desenvolvimento de novas bibliotecas, até o suporte aos usuários.

- Milhares de funções de analise de  dados no estilo caixa-preta.

- Ambiente de produção e visualização de gráficos.

- Processamento em memória.

- Integração "out of box" com quase tudo: Oracle, SQL Server, .NET, Java, Python, Tableau, Power BI, Handoop, etc.

- Saiba mais em: [r-project.org](https://www.r-project.org/about.html) 


---
class: middle

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="img/rstudio.png" alt="&lt;center&gt;&lt;b&gt; &lt;/center&gt;&lt;/b&gt;" width="45%" /&gt;
&lt;p class="caption"&gt;&lt;center&gt;&lt;b&gt; &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/div&gt;

- Optar por programar em R também implica na escolha de uma IDE (Integrated Development Environment) que, na grande maioria dos casos, será o RStudio. Outra indicação é o próprio VScode, devido sua adequação com outras linguagens que podemos vir a utilizar.

- O RStudio é um conjunto de ferramentas integradas projetadas (IDE - Integrated Development Environment) da linguagem R para editar e executar os códigos em R.

- O R, em combinação com o RStudio, possui um conjunto de funcionalidades cuja intenção é ajudar no processo de desenvolvimento.


- Saiba mais em: [https://rstudio.com/](https://rstudio.com/) 



---
class: middle

# RStudio

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="figures/rstudio1.png" alt="&lt;center&gt;&lt;b&gt; &lt;/center&gt;&lt;/b&gt;" width="100%" /&gt;
&lt;p class="caption"&gt;&lt;center&gt;&lt;b&gt; &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/div&gt;
---
class: middle

# RStudio


* **Editor/Scripts**: É onde escrever os códigos. Arquivos do tipo .R. 

* **Console**: Executar os comandos e ver os resultados. 

* **Enviroment**: Painel com todos os objetos criados.

* **History**: História dos comandos executados. 

* **Files**: Navegar em pastas e arquivos. 

* **Plots**: Onde os gráficos serão apresentados.

* **Packages**: Pacotes instalados (sem ticar) e habilitados (ticados). 

* **Help**: Retorna o tutorial de ajuda do comando solicitado com help() ou ?comando. Veremos melhor como pedir ajuda no R ainda nessa aula. 


---
class: middle

# Rproj e diretórios

- Organizar arquivos é uma parte integral do processo de programação.

- Denominados “repositorios”, eles não passam de pastas comuns com um arquivo .Rproj (projeto).

- A organização dos arquivos bem como dos scripts é muito importante, tanto para importação em núvem quanto para o trabalho em grupo.



Uma funcionalidade importante é a criação de projetos, permitindo dividir o trabalho em múltiplos ambientes, cada um com o seu diretório, documentos e workspace.

Para criar um projeto, os seguintes passos podem ser seguidos:

1) Clique na opção “File” do menu, e então em “New Project”.

2) Clique em “New Directory”.

3) Clique em “New Project”.

4) Escreva o nome do diretório (pasta) onde deseja manter seu projeto, ex “my_project”.

5) Clique no botão “Create Project”.

Para criar um novo script para escrever os códigos, vá em File -&gt; New File -&gt; R Script (Os passos descritos podem ser feitos via código, um bom treinamento para isso é o pacote swirl, aprendendo R no R).

---
class: middle

# Boas práticas

- Comente bem o seu código: É possível fazer comentários usando o símbolo ‘#’. É sempre bom explicar o que uma variável armazena, o que uma função faz, porque alguns parâmetros são passados para uma determinada função, qual é o objetivo de um trecho de código, etc.

- Evite linhas de código muito longas: Usar linhas de código mais curtas ajuda na leitura do código.

- Escreva um código organizado: Por exemplo, adote um padrão no uso de minúsculas e maiúsculas, uma lógica única na organização de pastas e arquivos, pode ser adotada uma breve descrição (como comentário) indicando o que um determinado script faz.

- Carregue todos os pacotes que irá usar sempre no início do arquivo: Quando alguém abrir o seu código será fácil identificar quais são os pacotes que devem ser instalados e quais dependências podem existir.

- Evite referência de caminho que considere seu computador ou usuário: Faça referência ao caminho do projeto.

- Use sempre nomes de variáveis que remetam a sua função evitando abreviações extremas.

---
class: middle

### R como calculadora 

&lt;!-- 1) Operadores --&gt;


```r
#adição
10+15
  #&gt; [1] 25
#subtração
10-2
  #&gt; [1] 8
#multiplicação
2*10
  #&gt; [1] 20
#divisão
30/2
  #&gt; [1] 15
#raiz quadrada
sqrt(4)
  #&gt; [1] 2
#potência
2^2
  #&gt; [1] 4
```
Se você digitar um comando incompleto, como 10 *, o R mostrará um +. Isso não tem a ver com a soma e apenas que o R está esperando você completar seu comando. Termine seu comando ou aperte Esc para recomeçar. 
&lt;!-- Vale também ressaltar que se você digitar um comando que o R não reconhece, ele retornará uma mensagem de erro e você pode digitar outro comando normalmente em seguida.  --&gt;

---
class: middle

### Atribuição 

Para atribuir a um objeto, o sinal de atribuição é = ou &lt;-. 
Exemplos:

```r
x &lt;- 10/2
x
  #&gt; [1] 5
X
  #&gt; Error in eval(expr, envir, enclos): objeto 'X' não encontrado
```
Por que tivemos um erro acima?

--

O R é case sensitive, isto é, faz a diferenciação entre as letras minúsculas e maiúsculas. Portanto, x é diferente de X. 

---
class: middle

### Objetos em R

Existem cinco classes básicas no R:

* character: "UAH!" 

* numeric: 0.95 (números reais)

* integer: 100515 (inteiros)

* complex: 2 + 5i (números complexos, a + bi)

* logical: TRUE (booleanos, TRUE/FALSE)

---
class: middle

Vamos atribuir a x a string banana. 

```r
x &lt;- banana 
  #&gt; Error in eval(expr, envir, enclos): objeto 'banana' não encontrado
x &lt;- "banana"
x
  #&gt; [1] "banana"
```
O primeiro caso (x&lt;-banana) não deu certo, pois ele entendeu que estamos atribuindo a x outro objeto banana, que não foi declarado. Para atribuir o string banana à x, precisamos colocar entre aspas ou aspas simples. Uma string sem aspas é entendido como um objeto, veja abaixo:

```r
banana &lt;- 30
x &lt;- banana
x
  #&gt; [1] 30
```


---
class: middle

Função class().


```r
y &lt;- "ola"
class(y)
  #&gt; [1] "character"

x &lt;- 2.5
class(x)
  #&gt; [1] "numeric"
```

Apagar objetos


```r
x &lt;- 20
x
  #&gt; [1] 20
remove(x)
x
  #&gt; Error in eval(expr, envir, enclos): objeto 'x' não encontrado
```

E se eu quiser limpar o console - apaga todos os objetos atribuidos até aqui:

```r
rm(list=ls())
```

---
class: middle

### Data Strutures
* atomic vector

* matrix

* factors

* data frame

* list
---
class: middle

### Vetor
 &lt;!-- Como atribuir varios valores a um objeto?  Para entrar com vários números (ou nomes, ou qualquer outro grupo de coisas), precisamos usar uma função para dizer ao programa que os valores serão combinados em um único vetor. --&gt;

```r
x &lt;- c(2,3,4)
x
  #&gt; [1] 2 3 4
y &lt;- seq(1:10)
y
  #&gt;  [1]  1  2  3  4  5  6  7  8  9 10
z &lt;- rep(1,10)
z
  #&gt;  [1] 1 1 1 1 1 1 1 1 1 1
a &lt;- 1:10
a
  #&gt;  [1]  1  2  3  4  5  6  7  8  9 10
bicho &lt;-c("macaco","pato","galinha","porco")
bicho
  #&gt; [1] "macaco"  "pato"    "galinha" "porco"
```
E se quisermos visualizar o conteúdo da posição 2 no vetor bicho?

```r
bicho[2]
  #&gt; [1] "pato"
```


---
class: middle

Operações vetoriais


```r
k &lt;- x*2
y &lt;- c(x,k)
y
  #&gt; [1] 2 3 4 4 6 8
```
&lt;!-- Vale mencionar que o separador de decimais no R é . (ponto)!  --&gt;

Como calcularia o IMC de 6 pessoas?
--


```r
peso &lt;- c(62, 70, 52, 98, 90, 70)
altura &lt;- c(1.70, 1.82, 1.75, 1.94, 1.84, 1.61)
imc &lt;- peso/(altura^2)
imc
  #&gt; [1] 21.45329 21.13271 16.97959 26.03890 26.58318 27.00513
```

Função length(). 

```r
length(imc)
  #&gt; [1] 6
```

O R, assim como muitas linguagens atuais, é bem intuitivo quanto a funcionalidade de suas funções, mas sempre podemos verificar usando "?nome_da_funcao()" ou utilizando help(funcao).

---
class: middle

### Matrizes

- Matriz[linha, coluna].


```r
x &lt;- matrix(seq(1:16), nrow=4,ncol=4); x
  #&gt;      [,1] [,2] [,3] [,4]
  #&gt; [1,]    1    5    9   13
  #&gt; [2,]    2    6   10   14
  #&gt; [3,]    3    7   11   15
  #&gt; [4,]    4    8   12   16
x[2,3] #retorna o elemento na segunda linha e terceira coluna da matriz
  #&gt; [1] 10
x[3,  ]   # seleciona a 3ª linha
  #&gt; [1]  3  7 11 15
x[ , 2]   # seleciona a 2ª coluna
  #&gt; [1] 5 6 7 8
x[1,] &lt;- c(13,15,19,30)  #substituir a primeira linha por (13,15,19,30)

x
  #&gt;      [,1] [,2] [,3] [,4]
  #&gt; [1,]   13   15   19   30
  #&gt; [2,]    2    6   10   14
  #&gt; [3,]    3    7   11   15
  #&gt; [4,]    4    8   12   16
```
dimensao da matriz x?

```r
dim(x)
  #&gt; [1] 4 4
```
---
class: middle

Concatenar linhas em uma matriz

```r
vet &lt;- c(2,20,12,34)
x2 &lt;- rbind(x,vet); x2
  #&gt;     [,1] [,2] [,3] [,4]
  #&gt;       13   15   19   30
  #&gt;        2    6   10   14
  #&gt;        3    7   11   15
  #&gt;        4    8   12   16
  #&gt; vet    2   20   12   34
```

Concatenar colunas em uma matriz

```r
v2 &lt;- c(25,10,15,4) 
x3 &lt;- cbind(x,v2); x3
  #&gt;                  v2
  #&gt; [1,] 13 15 19 30 25
  #&gt; [2,]  2  6 10 14 10
  #&gt; [3,]  3  7 11 15 15
  #&gt; [4,]  4  8 12 16  4
```



---
class: middle

Operações matriciais

```r
xa &lt;- x2[1:2,1:2]
xb &lt;- matrix(rnorm(4),2,2)
xa*xb #multiplicacao ponto a ponto
  #&gt;        [,1]       [,2]
  #&gt;  13.0023526 -26.348716
  #&gt;  -0.7855189  -4.722797
xa%*%xb #multiplicacao matricial
  #&gt;        [,1]       [,2]
  #&gt;   7.1109605 -34.642547
  #&gt;  -0.3561949  -8.235959
solve(xa) #inversa de xa
  #&gt;                            
  #&gt; [1,]  0.12500000 -0.3125000
  #&gt; [2,] -0.04166667  0.2708333
diag(xa) #matriz diagonal
  #&gt; [1] 13  6
```

---
class: middle

### Data frame
Trata-se de uma “tabela de dados” onde as colunas são as variáveis e as linhas são os registros. Essas colunas podem ser de classes diferentes. 
As linhas e as colunas podem ter nomes.
Essa é a grande diferença entre data.frame’s e matrizes (matriz é só numerica).

Posso criar um data frame no R com os vetores, por exemplo:

```r
ID &lt;- seq(1:6)
pes &lt;- c(62, 70, 52, 98, 90, 70)
alt &lt;- c(1.70, 1.82, 1.75, 1.94, 1.84, 1.61)
imc &lt;- pes/(alt^2)
dados &lt;- data.frame(ID=ID,peso=pes,altura=alt, imc=imc)
dados
  #&gt;   ID peso altura      imc
  #&gt; 1  1   62   1.70 21.45329
  #&gt; 2  2   70   1.82 21.13271
  #&gt; 3  3   52   1.75 16.97959
  #&gt; 4  4   98   1.94 26.03890
  #&gt; 5  5   90   1.84 26.58318
  #&gt; 6  6   70   1.61 27.00513
```

---
class: middle

Selecionar a variavel/coluna de interesse:

```r
dados$altura
  #&gt; [1] 1.70 1.82 1.75 1.94 1.84 1.61
```

Putz, esqueci de colocar a varivel de grupo no data frame. Tenho que criar tudo de novo? Não:

```r
gr &lt;- c(rep(1,3),rep(2,3))
dados$grupo &lt;- gr

dados
  #&gt;   ID peso altura      imc grupo
  #&gt; 1  1   62   1.70 21.45329     1
  #&gt; 2  2   70   1.82 21.13271     1
  #&gt; 3  3   52   1.75 16.97959     1
  #&gt; 4  4   98   1.94 26.03890     2
  #&gt; 5  5   90   1.84 26.58318     2
  #&gt; 6  6   70   1.61 27.00513     2
```

---
class: middle

Funcoes uteis para data.frame:

* head() - Mostra as primeiras 6 linhas.

* tail() - Mostra as últimas 6 linhas.

* dim() - Número de linhas e de colunas.

* names() - Os nomes das colunas (variáveis).

* str() - Estrutura do data.frame. Mostra, entre outras coisas, as classes de cada coluna.



```r
names(dados)
  #&gt; [1] "ID"     "peso"   "altura" "imc"    "grupo"
str(dados)
  #&gt; 'data.frame':	6 obs. of  5 variables:
  #&gt;  $ ID    : int  1 2 3 4 5 6
  #&gt;  $ peso  : num  62 70 52 98 90 70
  #&gt;  $ altura: num  1.7 1.82 1.75 1.94 1.84 1.61
  #&gt;  $ imc   : num  21.5 21.1 17 26 26.6 ...
  #&gt;  $ grupo : num  1 1 1 2 2 2
```

---
class: middle


```r
mean(dados$imc)
  #&gt; [1] 23.1988
sd(dados$imc)
  #&gt; [1] 4.00006
summary(dados$imc)
  #&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  #&gt;   16.98   21.21   23.75   23.20   26.45   27.01
```


```r
table(dados$grupo)
  #&gt; 
  #&gt; 1 2 
  #&gt; 3 3
```

---
class: middle

### Fator
&lt;!-- Fatores podem ser vistos como vetores de inteiros que possuem rótulos (labels). Eles são úteis para representar uma variável categórica (nominal e ordinal). --&gt;


```r
sexo &lt;- c("M", "H", "H", "H", "M", "M", "H")
sex &lt;- as.factor(sexo)
sex
  #&gt; [1] M H H H M M H
  #&gt; Levels: H M
levels(sex)
  #&gt; [1] "H" "M"
```

---
class: middle

### Arrays
- É uma forma generalizada da matriz. Um vetor tem apenas uma dimensão: tamanho. A matriz tem apenas duas dimensões: linhas e colunas. Um array pode ser n dimensões.

```r
dim3 &lt;- array(rnorm(18),dim = c(3,3,2))
dim3
  #&gt; , , 1
  #&gt; 
  #&gt;            [,1]       [,2]      [,3]
  #&gt; [1,] -0.3416793 -0.3392736 0.9462810
  #&gt; [2,]  0.2228796 -0.7183302 1.4212030
  #&gt; [3,]  0.9087406 -1.3130519 0.5826473
  #&gt; 
  #&gt; , , 2
  #&gt; 
  #&gt;             [,1]       [,2]       [,3]
  #&gt; [1,] -0.31119523 -0.7231289  1.7085356
  #&gt; [2,]  0.59351611  2.4845654 -1.2619251
  #&gt; [3,] -0.03417944 -0.5476993 -0.7317452
```

---
class: middle

### Lists
- Parecido com a ideia de Array, porém podemos armazenar diferentes tipos de dados em diferentes tamanhos. Ex: o item 1 da lista pode ser um vetor, enquanto o segundo um inteiro e o terceiro uma matriz ou até mesmo outra lista.
.scroll-box-14[

```r
ls &lt;- list(ls1 = 'a',ls2 = c(1,2,3),ls3 = array(rnorm(6),dim = c(3,1,2,1))); ls
  #&gt; $ls1
  #&gt; [1] "a"
  #&gt; 
  #&gt; $ls2
  #&gt; [1] 1 2 3
  #&gt; 
  #&gt; $ls3
  #&gt; , , 1, 1
  #&gt; 
  #&gt;             [,1]
  #&gt; [1,] -0.38597191
  #&gt; [2,]  0.02400236
  #&gt; [3,]  0.23717288
  #&gt; 
  #&gt; , , 2, 1
  #&gt; 
  #&gt;            [,1]
  #&gt; [1,]  0.6695601
  #&gt; [2,] -0.3741944
  #&gt; [3,]  1.4018673
```
]
---
class: middle

## Operadores Relacionais
Igual a: ==


```r
10==11
  #&gt; [1] FALSE
```

Diferente de: !=


```r
10!=11
  #&gt; [1] TRUE
```

* Maior que: &gt; 

* Maior ou igual: &gt;= 

* Menor que: &lt; 

* Menor ou igual: &lt;= 

---
class: middle

## Operadores Lógicos

* E: &amp; - será verdadeiro se os dois forem TRUE


```r
x &lt;- 15
x &gt; 10 &amp; x &lt; 30
  #&gt; [1] TRUE

x &lt; 10 &amp; x &lt; 30
  #&gt; [1] FALSE
```

* OU: | - será verdadeiro se um dos dois for TRUE


```r
x &gt; 10 | x &gt; 30
  #&gt; [1] TRUE
```

* Negação: ! 


```r
x &lt;- 15
!x&lt;30
  #&gt; [1] FALSE
```

---
class: middle

### If e else


```r
a &lt;- 224
b &lt;- 225
if (a==b) { v=10
} else {v=15}
v
  #&gt; [1] 15
```


```r
a &lt;- 224
b &lt;- 225
if (a==b) { v=10
} else if (a &gt; b) {v=15
} else {v=25}
v
  #&gt; [1] 25
```
Note que a condição de igualdade é representada por dois iguais ==. Como dito anteriormente, apenas um igual = é símbolo de atribuição. 

---
class: middle

### Looping e repetidores

```r
m &lt;- c(1,20,50,60,100)
```
Quero criar um novo vetor, p digamos,  que seja formado por cada elemento 
de m dividido por sua posição. 

```r
p &lt;- rep(0,length(m))
for (i in 1: length(m)){
  p[i] &lt;- m[i]/i
}
p
  #&gt; [1]  1.00000 10.00000 16.66667 15.00000 20.00000
#ou 
i = 1
while(i &lt; length(m)){
    p[i] &lt;- m[i]/i
    i &lt;- i + 1
}
p
  #&gt; [1]  1.00000 10.00000 16.66667 15.00000 20.00000
```
Note que primeiro definimos o objeto p. 

---
class: middle

### Funções 

```r
f.soma &lt;- function(x,y) {
  out &lt;- x+y
  return(out)
}
```
 * o nome: f.soma;
 
 * os argumentos: x e y;
 
 * o corpo out &lt;- x+y  e
 
 * o que retorna return(out).

Vamos agora chamar a função:

```r
f.soma(x=10,y=20)
  #&gt; [1] 30

f.soma(10,20)
  #&gt; [1] 30
```

---
class: middle

## Dados faltantes, infinitos e indefinições matemáticas

* NA (Not Available): dado faltante/indisponível. 

* NaN (Not a Number): indefinições matemáticas. Como 0/0 e log(-1).

* Inf (Infinito): número muito grande ou o limite matemático. Aceita sinal negativo -Inf.


---
class: middle

### Como obter ajuda no R

  * Help/documentação do R 

```r
help(mean) #ou
?mean
```

* Google.
&lt;img src="figures/help_R.png" width="60%" style="display: block; margin: auto;" /&gt;

* Comunidade.

[Stack Overflow](https://stackoverflow.com/) e o [Stack Overflow em Português](https://pt.stackoverflow.com/). 


---
class: middle


## Pacotes

### Instalação

* Via CRAN: install.packages("nome-do-pacote").

install.packages("tidyverse")

Note que o nome do pacote está entre aspas. 

* Via Github: devtools::install_github("nome-do-repo/nome-do-pacote").

devtools::install_github("tidyverse/dplyr")

### Carregar pacotes:

library(nome-do-pacote)

Para carregar o pacote, não usar aspas.

Só é necessário instalar o pacote uma vez, mas precisa carregá-lo toda vez que começar uma nova sessão.



---
class: middle

# Importação de dados

## Extensão .txt ou .csv

Opção com o pacote **readr**.


```r
library(readr) #pacote readr
dados_csv &lt;- read_csv(file = "dados1.csv")
dados_txt &lt;- read_delim(file = "caminho-para-o-arquivo/dados1.txt", delim = " ")
```

&lt;!-- O argumento file= representa o caminho onde o arquivo está alocado. Se o arquivo estiver no diretório de trabalho, não precisa especificar o caminho até o arquivo. O argumento delim= indica qual caracter separa cada coluna no arquivo de texto. --&gt;
 
Outra opção: 
&lt;!-- para leitura de arquivo .txt é usar a função read.table que já está salva na base, ou seja, não é necessário instalar pacote.  --&gt;


```r
dados_txt2 &lt;- read.table(file="dados1.txt",header=T)
```

&lt;!-- O argumento header indica se a primeira linha do arquivo consta o nome das variáveis. Se for T (TRUE), a primeira linha é indicada como nome das variáveis. O default é header=F.  --&gt;

Vale ressaltar que para cada função read_, existe uma respectiva função write_ para salvar o arquivo no formato de interesse. Como exemplo, queremos salvar a base de dados cars. 


```r
write_csv(x = mtcars, path = "cars.csv")
write_delim(x = mtcars, delim = " ", path = "cars.txt"))
```

---
class: middle

## Arquivos em Excel

O pacote **readxl** pode ser utilizado para leiturade arquivos do Excel, como .xls e xlsx.


```r
library(readxl)
dados_excel &lt;- read_xls(path = "dados1.xls") #Leitura do arquivo .xls
dados_excelx &lt;- read_xlsx(path = "dados1.xlsx") #Leitura do arquivo .xlsx
```

Uma maneira mais simples é a utilização da função read_excel(), pois ela auto detecta a extensão do arquivo.

```r
library(readxl)
dados_excel1 &lt;- read_excel(path = "dados1.xls")
dados_excelx1 &lt;- read_excel(path = "dados1.xlsx")
```



## Arquivos de outros softwares

&lt;!-- Para ler dados salvos em extensão de outros softwares: SPSS, STATA e SAS: pacote haven.  --&gt;


```r
library(haven)
dados_stata &lt;- read_stata("dados1.dta")
dados_spss &lt;- read_spss("dados1.sav")
dados_sas &lt;- read_sas("dados1.sas7bdat")  
```

&lt;!-- Outra opção de pacote para importação de dados de outros softwares é o foreign. Além do SAS, STAT e SPSS, ele também lê dados do Octave, Minitab e Epi Info.  --&gt;

---
class: middle
## Exercicíos 1:
1. Crie duas variáveis Ana e Paulo e atribua a elas valores de suas idades, sendo respectivamente 8 e 12 anos. As variáveis devem ser do tipo inteiro. Imprima no console "A menina é mais velha" ou "O menino é mais velho" como resultado de um teste lógico.

2. BOD é um objeto existente no R. Verifique qual a classe deste objeto.

3. Crie um vetor que armazene números de 1 a 10 e posteriormente imprima os valores pares.

4. women é um dataframe existente no R. Imprima as 10 últimas linhas.

5. Use a função plot do R para produzir um gráfico do atributos Sepal.Width e Petal.Length do conjunto de dados Iris. O gráfico deve imprimir apenas das linhas 50 até 100.
6. Crie dois vetores de tamanhos iguais, some as posições equivalentes dos vetores e imprima o  resultado.
7. Imprima o número de linhas, de colunas, nomes das linhas e nome das colunas do conjunto de dados CO2

---
class: middle

## Tratamento de dados

A análise de consistência consiste em realizar uma primeira análise dos dados com o intuito de encontrar inconsistências. 
* boas práticas para nome das variáveis. 
* identificar erros de digitação;
* indivíduos imputados mais de uma vez na planilha de dados de maneira errada; 
* identificar casos missings e avaliar se a observação está ausente de maneira correta ou não;
* identificar as categorias de variáveis qualitativas.

Consideramos como exemplo os dados fictícios de `\(n=30\)` gestações gemelares. Vamos considerar duas bases de dados. Na primeira, chamada de "Base_CTG_caracterizacao" estão contidas as informações de caracterização das gestantes e gestações. 

Para importar a base de dados: 

```r
library(readxl)
dados &lt;- read_excel(path = "Base_CTG_caracterizacao.xls",na="NA")
dados
  #&gt; # A tibble: 34 × 13
  #&gt;       ID CORION `Data aval`         `Data nascimento`   `COR BRANCO` `Peso Pré`
  #&gt;    &lt;dbl&gt; &lt;chr&gt;  &lt;dttm&gt;              &lt;dttm&gt;                     &lt;dbl&gt;      &lt;dbl&gt;
  #&gt;  1     1 Di     2017-04-23 00:00:00 1988-04-30 00:00:00            1         93
  #&gt;  2     2 Mono   2016-03-21 00:00:00 1982-03-30 00:00:00            1         59
  #&gt;  3     2 Mono   2016-03-21 00:00:00 1982-03-30 00:00:00            1         59
  #&gt;  4     3 Di     2016-02-17 00:00:00 1991-02-23 00:00:00            0         87
  #&gt;  5     4 Di     2017-12-14 00:00:00 1983-12-23 00:00:00            1         52
  #&gt;  6     5 Di     2017-04-23 00:00:00 1988-04-30 00:00:00            0         78
  #&gt;  7     6 Di     2016-03-21 00:00:00 1989-03-28 00:00:00            0         62
  #&gt;  8     7 Di     2016-02-17 00:00:00 1985-02-24 00:00:00            0         54
  #&gt;  9     8 Di     2017-12-14 00:00:00 1988-12-21 00:00:00            1         72
  #&gt; 10     9 Di     2017-04-23 00:00:00 1980-05-02 00:00:00            3         72
  #&gt; # ℹ 24 more rows
  #&gt; # ℹ 7 more variables: ALT &lt;dbl&gt;, Gesta &lt;dbl&gt;, Para &lt;dbl&gt;, Aborto &lt;dbl&gt;,
  #&gt; #   `IGP semana` &lt;dbl&gt;, `IGP dia` &lt;dbl&gt;, oi &lt;lgl&gt;
```



---
class: middle

##Exercício

Na base em excel, retire os NA's, deixando em branco, e rode o seguinte comando:


```r
library(readxl)
dados &lt;- read_excel(path = "Base_CTG_caracterizacao.xls")
```
O default do missing é o espaço em branco. Acesse o help em ?read_excel e veja na = "".  

---
class: middle

### Nome das variáveis

Utilizaremos as funções tidyverse e janitor para a arrumação da base de dados. 



```r
library(tidyverse)
library(janitor)

names(dados)
  #&gt;  [1] "ID"              "CORION"          "Data aval"       "Data nascimento"
  #&gt;  [5] "COR BRANCO"      "Peso Pré"        "ALT"             "Gesta"          
  #&gt;  [9] "Para"            "Aborto"          "IGP semana"      "IGP dia"        
  #&gt; [13] "oi"
dados &lt;- clean_names(dados) # a função clean_names() para primeiro ajuste dos nomes das variaveis
names(dados)
  #&gt;  [1] "id"              "corion"          "data_aval"       "data_nascimento"
  #&gt;  [5] "cor_branco"      "peso_pre"        "alt"             "gesta"          
  #&gt;  [9] "para"            "aborto"          "igp_semana"      "igp_dia"        
  #&gt; [13] "oi"
```

---
class: middle

### Linhas e colunas vazias 
 Na base de dados em questão, não há linhas vazias, como pode ser visto na saída abaixo. 


```r
dados &lt;- remove_empty(dados,"rows")
```

Propositalmente, inclui a coluna "oi" vazia para podermos eliminá-la com o comando abaixo: 

```r
dados &lt;- remove_empty(dados,"cols")
names(dados)
  #&gt;  [1] "id"              "corion"          "data_aval"       "data_nascimento"
  #&gt;  [5] "cor_branco"      "peso_pre"        "alt"             "gesta"          
  #&gt;  [9] "para"            "aborto"          "igp_semana"      "igp_dia"
```

---
class: middle

### Identificação de casos duplicados

&lt;!-- Uma boa prática consiste em identificar casos duplicados, isto é, identificar se há casos erroneamente repetidos. No exemplo, a variável chave é id, em que cada indivíduo distinto apresenta um id distinto.  Para identificar casos duplicados pela variável chave "id", usamos a função get_dupes do pacote janitor.  --&gt;


```r
get_dupes(dados, id)
  #&gt; # A tibble: 8 × 13
  #&gt;      id dupe_count corion data_aval           data_nascimento     cor_branco
  #&gt;   &lt;dbl&gt;      &lt;int&gt; &lt;chr&gt;  &lt;dttm&gt;              &lt;dttm&gt;                   &lt;dbl&gt;
  #&gt; 1     2          2 Mono   2016-03-21 00:00:00 1982-03-30 00:00:00          1
  #&gt; 2     2          2 Mono   2016-03-21 00:00:00 1982-03-30 00:00:00          1
  #&gt; 3    11          2 Di     2016-02-17 00:00:00 1981-02-25 00:00:00          1
  #&gt; 4    11          2 Di     2016-02-17 00:00:00 1981-02-25 00:00:00          1
  #&gt; 5    17          2 Di     2017-04-23 00:00:00 1993-04-29 00:00:00          1
  #&gt; 6    17          2 Di     2017-04-23 00:00:00 1993-04-29 00:00:00          1
  #&gt; 7    23          2 Di     2016-02-17 00:00:00 1997-02-21 00:00:00          1
  #&gt; 8    23          2 Di     2016-02-17 00:00:00 1997-02-21 00:00:00          1
  #&gt; # ℹ 7 more variables: peso_pre &lt;dbl&gt;, alt &lt;dbl&gt;, gesta &lt;dbl&gt;, para &lt;dbl&gt;,
  #&gt; #   aborto &lt;dbl&gt;, igp_semana &lt;dbl&gt;, igp_dia &lt;dbl&gt;
```
&lt;!-- No exemplo, note que os IDs=2, 11, 17 e 23 aparecem dois casos cada, o que não está correto para essa aplicação.  --&gt;
&lt;!-- Para eliminar linhas duplicadas identificadas, usamos a função distinct do pacote dplyr. No objeto dados1 salvamos os dados sem os casos duplicados.  --&gt;

---
class: middle


```r
library(dplyr)
dados1 &lt;-  distinct(dados,id, .keep_all = TRUE)
dados1
  #&gt; # A tibble: 30 × 12
  #&gt;       id corion data_aval           data_nascimento     cor_branco peso_pre
  #&gt;    &lt;dbl&gt; &lt;chr&gt;  &lt;dttm&gt;              &lt;dttm&gt;                   &lt;dbl&gt;    &lt;dbl&gt;
  #&gt;  1     1 Di     2017-04-23 00:00:00 1988-04-30 00:00:00          1       93
  #&gt;  2     2 Mono   2016-03-21 00:00:00 1982-03-30 00:00:00          1       59
  #&gt;  3     3 Di     2016-02-17 00:00:00 1991-02-23 00:00:00          0       87
  #&gt;  4     4 Di     2017-12-14 00:00:00 1983-12-23 00:00:00          1       52
  #&gt;  5     5 Di     2017-04-23 00:00:00 1988-04-30 00:00:00          0       78
  #&gt;  6     6 Di     2016-03-21 00:00:00 1989-03-28 00:00:00          0       62
  #&gt;  7     7 Di     2016-02-17 00:00:00 1985-02-24 00:00:00          0       54
  #&gt;  8     8 Di     2017-12-14 00:00:00 1988-12-21 00:00:00          1       72
  #&gt;  9     9 Di     2017-04-23 00:00:00 1980-05-02 00:00:00          3       72
  #&gt; 10    10 Di     2016-03-21 00:00:00 1984-03-29 00:00:00          1      102
  #&gt; # ℹ 20 more rows
  #&gt; # ℹ 6 more variables: alt &lt;dbl&gt;, gesta &lt;dbl&gt;, para &lt;dbl&gt;, aborto &lt;dbl&gt;,
  #&gt; #   igp_semana &lt;dbl&gt;, igp_dia &lt;dbl&gt;
```
&lt;!-- Ao chamar os dados1,  apenas as dez primeiras linhas são impressas na tela e as colunas que não couberem na largura do console serão omitidas. Vale ressaltar que também são apresentadas a dimensão da tabela (no exemplo, 30X12) e as classes de cada coluna. --&gt;

---
class: middle


### Identificar tipo e classe de todas as variáveis da base
Para identificar a classe de todas as variáveis que o R está interpretando, usamos a função str(.).  


```r
# Ver a estrutura dos dados
str(dados1)
  #&gt; tibble [30 × 12] (S3: tbl_df/tbl/data.frame)
  #&gt;  $ id             : num [1:30] 1 2 3 4 5 6 7 8 9 10 ...
  #&gt;  $ corion         : chr [1:30] "Di" "Mono" "Di" "Di" ...
  #&gt;  $ data_aval      : POSIXct[1:30], format: "2017-04-23" "2016-03-21" ...
  #&gt;  $ data_nascimento: POSIXct[1:30], format: "1988-04-30" "1982-03-30" ...
  #&gt;  $ cor_branco     : num [1:30] 1 1 0 1 0 0 0 1 3 1 ...
  #&gt;  $ peso_pre       : num [1:30] 93 59 87 52 78 62 54 72 72 102 ...
  #&gt;  $ alt            : num [1:30] 1.63 1.45 1.69 1.55 1.59 1.64 NA 1.64 1.65 1.68 ...
  #&gt;  $ gesta          : num [1:30] 3 3 2 2 7 7 2 2 8 3 ...
  #&gt;  $ para           : num [1:30] 1 1 1 0 2 4 1 1 4 2 ...
  #&gt;  $ aborto         : num [1:30] 1 1 0 1 4 2 0 0 3 0 ...
  #&gt;  $ igp_semana     : num [1:30] 37 37 35 38 38 29 38 34 36 37 ...
  #&gt;  $ igp_dia        : num [1:30] 4 3 0 1 3 3 3 6 3 5 ...
```

---
class: middle


```r
dados1$data_aval  &lt;- as.Date(dados1$data_aval)
dados1$data_nascimento  &lt;- as.Date(dados1$data_nascimento)
str(dados1)
  #&gt; tibble [30 × 12] (S3: tbl_df/tbl/data.frame)
  #&gt;  $ id             : num [1:30] 1 2 3 4 5 6 7 8 9 10 ...
  #&gt;  $ corion         : chr [1:30] "Di" "Mono" "Di" "Di" ...
  #&gt;  $ data_aval      : Date[1:30], format: "2017-04-23" "2016-03-21" ...
  #&gt;  $ data_nascimento: Date[1:30], format: "1988-04-30" "1982-03-30" ...
  #&gt;  $ cor_branco     : num [1:30] 1 1 0 1 0 0 0 1 3 1 ...
  #&gt;  $ peso_pre       : num [1:30] 93 59 87 52 78 62 54 72 72 102 ...
  #&gt;  $ alt            : num [1:30] 1.63 1.45 1.69 1.55 1.59 1.64 NA 1.64 1.65 1.68 ...
  #&gt;  $ gesta          : num [1:30] 3 3 2 2 7 7 2 2 8 3 ...
  #&gt;  $ para           : num [1:30] 1 1 1 0 2 4 1 1 4 2 ...
  #&gt;  $ aborto         : num [1:30] 1 1 0 1 4 2 0 0 3 0 ...
  #&gt;  $ igp_semana     : num [1:30] 37 37 35 38 38 29 38 34 36 37 ...
  #&gt;  $ igp_dia        : num [1:30] 4 3 0 1 3 3 3 6 3 5 ...
```


---
class: middle


### Identificar tipo e classe de todas as variáveis da base

Utilizamos a função as.Date(.) porque queríamos mudar para tipo data. Abaixo está a lista das funções para mudança de tipo.

* **as.character** -  converte para variável texto.

* **as.numeric** - converte para variável número.

* **as.factor** - converte para variável categórica.

* **as.integer** - converte para variável inteiro.

* **as.Date** - converte para variável data.

* **as.POSIXct** - converte para variável data e hora completa. 


---
class:  middle

### Identificar erros
Para variáveis qualitativas: tabela de frequências da variável corion. 


```r
#do pacote janitor
tabyl(dados1,corion) 
  #&gt;  corion  n    percent
  #&gt;      DI  1 0.03333333
  #&gt;      Di 25 0.83333333
  #&gt;    MONO  1 0.03333333
  #&gt;    Mono  3 0.10000000
```

Para lidar com variáveis de texto, vamos utilizar a função str_to_lower do pacote stringr.


```r

library(stringr)
dados1$corion &lt;- str_to_lower(dados1$corion)
tabyl(dados1,corion)
  #&gt;  corion  n   percent
  #&gt;      di 26 0.8666667
  #&gt;    mono  4 0.1333333
```

---
class: middle

A variável indicadora de cor branca (cor_branco) está categorizada como 0 para não e 1 para sim.  

```r
tabyl(dados1,cor_branco)
  #&gt;  cor_branco  n    percent
  #&gt;           0 12 0.40000000
  #&gt;           1 17 0.56666667
  #&gt;           3  1 0.03333333
dados1$cor_branco &lt;- ifelse(dados1$id==9,1,dados1$cor_branco)
```




No R tem um pacote só para manipular fatores: o **forcats** (for categorial variables). 

Primeiro, precisamos informar o R que a variável é fator, com o comando as.factor(.).

```r
library(forcats)
dados1$cor_branco  &lt;- as.factor(dados1$cor_branco)
dados1$cor_branco &lt;- fct_recode(dados1$cor_branco,
           branco = "1", 
           nbranco = "0")
tabyl(dados1,cor_branco)
  #&gt;  cor_branco  n percent
  #&gt;     nbranco 12     0.4
  #&gt;      branco 18     0.6
```
---
class: middle

Para fazer análise geral de todas as variáveis da base de dados, usamos a função skim(.) do pacote **skimr**. 

```r
library(skimr)
skim(dados)
```


Table: Data summary

|                         |      |
|:------------------------|:-----|
|Name                     |dados |
|Number of rows           |34    |
|Number of columns        |12    |
|_______________________  |      |
|Column type frequency:   |      |
|character                |1     |
|numeric                  |9     |
|POSIXct                  |2     |
|________________________ |      |
|Group variables          |None  |


**Variable type: character**

|skim_variable | n_missing| complete_rate| min| max| empty| n_unique| whitespace|
|:-------------|---------:|-------------:|---:|---:|-----:|--------:|----------:|
|corion        |         0|             1|   2|   4|     0|        4|          0|


**Variable type: numeric**

|skim_variable | n_missing| complete_rate|  mean|    sd|    p0|   p25|   p50|   p75|   p100|hist  |
|:-------------|---------:|-------------:|-----:|-----:|-----:|-----:|-----:|-----:|------:|:-----|
|id            |         0|          1.00| 15.24|  8.71|  1.00|  8.25| 15.50| 22.75|  30.00|▇▇▇▇▇ |
|cor_branco    |         0|          1.00|  0.71|  0.63|  0.00|  0.00|  1.00|  1.00|   3.00|▅▇▁▁▁ |
|peso_pre      |         1|          0.97| 66.94| 15.71| 44.00| 55.00| 62.00| 75.00| 102.00|▇▇▃▂▃ |
|alt           |         1|          0.97|  1.60|  0.08|  1.45|  1.55|  1.61|  1.64|   1.76|▃▆▆▇▂ |
|gesta         |         0|          1.00|  2.50|  1.93|  1.00|  1.00|  2.00|  3.00|   8.00|▇▂▁▁▁ |
|para          |         0|          1.00|  1.00|  1.21|  0.00|  0.00|  1.00|  1.00|   4.00|▇▆▂▂▁ |
|aborto        |         0|          1.00|  0.50|  0.96|  0.00|  0.00|  0.00|  1.00|   4.00|▇▂▁▁▁ |
|igp_semana    |         0|          1.00| 35.68|  2.23| 29.00| 34.25| 36.50| 37.00|  38.00|▁▁▃▃▇ |
|igp_dia       |         0|          1.00|  2.91|  1.56|  0.00|  2.00|  3.00|  3.00|   6.00|▃▃▇▁▃ |


**Variable type: POSIXct**

|skim_variable   | n_missing| complete_rate|min        |max        |median     | n_unique|
|:---------------|---------:|-------------:|:----------|:----------|:----------|--------:|
|data_aval       |         0|             1|2016-02-17 |2017-12-14 |2016-03-21 |        4|
|data_nascimento |         0|             1|1980-02-26 |1998-12-19 |1988-04-30 |       23|


---
class: middle

### Transformação de variáveis quantitativas

Calcular IMC (índice de massa corpórea) - peso (em km) dividido pela altura (em metros) ao quadrado.


```r
dados1 &lt;- mutate(dados1,imc = peso_pre/(alt^2))
skim(dados1,imc)
```


Table: Data summary

|                         |       |
|:------------------------|:------|
|Name                     |dados1 |
|Number of rows           |30     |
|Number of columns        |13     |
|_______________________  |       |
|Column type frequency:   |       |
|numeric                  |1      |
|________________________ |       |
|Group variables          |None   |


**Variable type: numeric**

|skim_variable | n_missing| complete_rate| mean|   sd|    p0|   p25|   p50|   p75|  p100|hist  |
|:-------------|---------:|-------------:|----:|----:|-----:|-----:|-----:|-----:|-----:|:-----|
|imc           |         2|          0.93| 26.6| 5.95| 16.36| 22.12| 25.97| 29.32| 40.69|▂▇▆▂▂ |



```r
str(dados1)
  #&gt; tibble [30 × 13] (S3: tbl_df/tbl/data.frame)
  #&gt;  $ id             : num [1:30] 1 2 3 4 5 6 7 8 9 10 ...
  #&gt;  $ corion         : chr [1:30] "di" "mono" "di" "di" ...
  #&gt;  $ data_aval      : Date[1:30], format: "2017-04-23" "2016-03-21" ...
  #&gt;  $ data_nascimento: Date[1:30], format: "1988-04-30" "1982-03-30" ...
  #&gt;  $ cor_branco     : Factor w/ 2 levels "nbranco","branco": 2 2 1 2 1 1 1 2 2 2 ...
  #&gt;  $ peso_pre       : num [1:30] 93 59 87 52 78 62 54 72 72 102 ...
  #&gt;  $ alt            : num [1:30] 1.63 1.45 1.69 1.55 1.59 1.64 NA 1.64 1.65 1.68 ...
  #&gt;  $ gesta          : num [1:30] 3 3 2 2 7 7 2 2 8 3 ...
  #&gt;  $ para           : num [1:30] 1 1 1 0 2 4 1 1 4 2 ...
  #&gt;  $ aborto         : num [1:30] 1 1 0 1 4 2 0 0 3 0 ...
  #&gt;  $ igp_semana     : num [1:30] 37 37 35 38 38 29 38 34 36 37 ...
  #&gt;  $ igp_dia        : num [1:30] 4 3 0 1 3 3 3 6 3 5 ...
  #&gt;  $ imc            : num [1:30] 35 28.1 30.5 21.6 30.9 ...
```

---
class: middle

##Exercício
Crie a variável igp (idade gestacional do parto) em semanas - obtida ao somar igp_semana e igp_dia/7. 

---
class: middle

## Transformação de variáveis qualitativas

A variável "gesta" indica o número de gestações, contando com a atual. Logo, uma gestante com gesta=1 está em sua primeira gestação, ou seja, é primigesta. Queremos criar uma nova variável indicadora de gestação primigesta. Há diferentes forma de fazer isso. Vamos usar o comando ifelse já utilizado anteriormente. 


```r
dados1$primigesta &lt;- ifelse(dados1$para==1,1,0)
tabyl(dados1,primigesta) 
  #&gt;  primigesta  n percent
  #&gt;           0 21     0.7
  #&gt;           1  9     0.3
```
Agora vamos recodificar primigesta com o nome de cada categoria: 

```r
dados1$primigesta &lt;- as.factor(dados1$primigesta)
dados1$primigesta &lt;- fct_recode(dados1$primigesta,
           nao = "0", 
           sim = "1")
tabyl(dados1,primigesta) 
  #&gt;  primigesta  n percent
  #&gt;         nao 21     0.7
  #&gt;         sim  9     0.3
```

---
class: middle

##Exercício:

1) Crie a variável indicador_aborto (sim e nao) - sim se aborto &gt;=1 e nao se aborto=0. 

2) Crie a variável primipara (sim e nao) - sim se para &gt;=1 e nao se para=0. 


---
class: middle

### Diferença de datas
Vamos calcular a idade das pacientes (data da avaliação e data do nascimento). Para realizar operações com data, usaremos o pacote **lubridate**. 

A data está salva no formato ano-mês-dia e por isso usamos a função ymd(.) para as variáveis de data. Para calcular a diferença entre as data, usamos a função `\(%--%\)`, atribuindo ao objeto intervalo. Por fim, obtemos a idade ao dividir o intervalo por ano.  

```r
library(lubridate)
intervalo &lt;- ymd(dados1$data_nascimento) %--%  ymd(dados1$data_aval)

dados1$idade &lt;- intervalo / dyears(1)  #número de anos

skim(dados1,idade)
```


Table: Data summary

|                         |       |
|:------------------------|:------|
|Name                     |dados1 |
|Number of rows           |30     |
|Number of columns        |15     |
|_______________________  |       |
|Column type frequency:   |       |
|numeric                  |1      |
|________________________ |       |
|Group variables          |None   |


**Variable type: numeric**

|skim_variable | n_missing| complete_rate|  mean|   sd|    p0|   p25|   p50|   p75|  p100|hist  |
|:-------------|---------:|-------------:|-----:|----:|-----:|-----:|-----:|-----:|-----:|:-----|
|idade         |         0|             1| 27.88| 6.05| 17.99| 23.23| 28.98| 33.73| 36.97|▆▅▇▃▇ |


&lt;!-- Vale ressaltar que há várias funções importantes para lidar com variáveis de data no pacote lubridate. Para mais detalhes, ver o [vignette](https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html). --&gt;

---
class: middle

### Combinação de bases de dados

Agora vamos considerar a segunda base de dados. Essa base de dados contém novas variáveis para os mesmos `\(n=30\)` gestantes, identificadas pela variável chave "id". 
Vamos então ler a base de dados, atribuindo para o objeto "dados.ctg".

```r
dados.ctg &lt;- read_excel(path = "Base_CTG_NumContraeColo.xls")

str(dados.ctg)
  #&gt; tibble [30 × 5] (S3: tbl_df/tbl/data.frame)
  #&gt;  $ ID            : num [1:30] 1 2 3 4 5 6 7 8 9 10 ...
  #&gt;  $ Grupo         : num [1:30] 2 1 1 1 2 1 2 1 1 2 ...
  #&gt;  $ IG_Aval       : num [1:30] 33.7 33.4 30.9 33 32.9 ...
  #&gt;  $ MedidaColo    : num [1:30] 33 34.6 25 27 32.8 20.6 33.1 28 21.8 46.3 ...
  #&gt;  $ Num_contra_CTG: num [1:30] 9 4 5 6 5 2 1 3 2 8 ...
```

---
class: middle


##EXERCÍCIO: 
Realize o tratamento da base de dados "dados.ctg". 


---
class: middle

Há algumas funções de combinação de duas bases de dados no pacote **dplyr**. Aqui estão as mais úteis:

* inner_join () - retorna valores de ambas as tabelas somente onde há uma correspondência.

* left_join () - retorna todos os valores da primeira tabela mencionada, mais os da segunda tabela correspondente.

* semi_join () - filtra a primeira tabela mencionada para incluir apenas os valores que possuem correspondências na segunda tabela.

* anti_join () - filtra a primeira tabela mencionada para incluir apenas valores que não possuem correspondências na segunda tabela.

---
class: middle


```r
dados.todos &lt;- inner_join(dados1, dados.ctg, by=c("id" = "ID"))

dados.todos
  #&gt; # A tibble: 30 × 19
  #&gt;       id corion data_aval  data_nascimento cor_branco peso_pre   alt gesta  para
  #&gt;    &lt;dbl&gt; &lt;chr&gt;  &lt;date&gt;     &lt;date&gt;          &lt;fct&gt;         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
  #&gt;  1     1 di     2017-04-23 1988-04-30      branco           93  1.63     3     1
  #&gt;  2     2 mono   2016-03-21 1982-03-30      branco           59  1.45     3     1
  #&gt;  3     3 di     2016-02-17 1991-02-23      nbranco          87  1.69     2     1
  #&gt;  4     4 di     2017-12-14 1983-12-23      branco           52  1.55     2     0
  #&gt;  5     5 di     2017-04-23 1988-04-30      nbranco          78  1.59     7     2
  #&gt;  6     6 di     2016-03-21 1989-03-28      nbranco          62  1.64     7     4
  #&gt;  7     7 di     2016-02-17 1985-02-24      nbranco          54 NA        2     1
  #&gt;  8     8 di     2017-12-14 1988-12-21      branco           72  1.64     2     1
  #&gt;  9     9 di     2017-04-23 1980-05-02      branco           72  1.65     8     4
  #&gt; 10    10 di     2016-03-21 1984-03-29      branco          102  1.68     3     2
  #&gt; # ℹ 20 more rows
  #&gt; # ℹ 10 more variables: aborto &lt;dbl&gt;, igp_semana &lt;dbl&gt;, igp_dia &lt;dbl&gt;,
  #&gt; #   imc &lt;dbl&gt;, primigesta &lt;fct&gt;, idade &lt;dbl&gt;, Grupo &lt;dbl&gt;, IG_Aval &lt;dbl&gt;,
  #&gt; #   MedidaColo &lt;dbl&gt;, Num_contra_CTG &lt;dbl&gt;
```

---
class: middle

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="figures/libraries-logo.png" alt="&lt;center&gt;&lt;b&gt; &lt;/center&gt;&lt;/b&gt;" width="70%" /&gt;
&lt;p class="caption"&gt;&lt;center&gt;&lt;b&gt; &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/div&gt;
Imagem de [Business Science](https://www.business-science.io/code-tools/2023/09/30/top-9-r-packages.html)
---

class: middle, center

## Obrigada!

![título](https://media.giphy.com/media/l3q2u6MXJJEKiTZIY/giphy.gif)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
